<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="UN_CleanroomConnect" Id="{8b93890b-f796-4713-9491-f75e01fbeba7}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK UN_CleanroomConnect EXTENDS Un_Base
VAR
	//Control Modules
	s_cmCabinStateIndicator : CM_TubeLedRgb;
	s_cmDoorLockCleanroomDoor : CM_DoorLock;
	
	//Function Blocks
	s_fbModeStateControl : FB_ModeStateControl;
	s_fbFlashSlow : FB_Flash;
	s_fbFlashFast : FB_Flash;
	
	//EM Pallet Conveyor
	s_fbIlckHandlerConvBwd : FB_InterlockHandler;
	s_fbIlckHandlerConvFwd : FB_InterlockHandler;
	
	//EM Docking Interface
	s_fbIlckHandlerClampsToClose : FB_InterlockHandler;
	s_fbIlckHandlerClampsToOpen : FB_InterlockHandler;
	s_fbIlckHandlerOuterCabinDoorClose : FB_InterlockHandler;
	s_fbIlckHandlerInnerCabinDoorClose : FB_InterlockHandler;
	
	//EM Lifting Transport
	s_fbIlckHandlerTranportExtract : FB_InterlockHandler;
	
	//Inputs
//??	s_diTwoHandControl : FB_DigInput;
	
	//Alarms
	
	//Params
	s_stSettings : ST_UN_CleanroomConnectSettings;
	
	//Variables
	s_bStaWarning : BOOL;
	s_bStaRunning : BOOL;
	
	s_bStaAllEmReady : BOOL;
	s_bStaEmError : BOOL;
	
	s_bStaDockTbDone: BOOL;
	s_bStaUnDockTbDone : BOOL;
	s_bStaOpenInnerTbDoorDone : BOOL;
	s_bStaCloseInnerTbDoorDone : BOOL;
	s_bStaPickTrolleyFromTbDone : BOOL;
	s_bStaPlaceTrolleyInTbDone : BOOL;
	
	s_eCtrlState : E_CtrlState;
	
	s_eCabinAirState : E_AirState := E_AirState.UNKNOWN;
	
	//Properties
	
	//Sequencers
	s_eSequence : E_SeqCleanroomConnect;
	s_fbSeqControl : FB_SeqControl;
	
	s_ePreviousStep : E_SeqCleanroomConnect;
	s_eResumeStep : E_SeqCleanroomConnect;
	s_sResumeStep : STRING;
	
	s_eReqAction : E_ReqAction;
	
	s_osrReqDockTb : F_TRIG;
	
	s_tonTimer : TON;
	
	//Hmi
	s_fbHmiBtnAlarms : FB_HmiBtn;
	s_fbHmiBtnReset : FB_HmiBtn;
	
	s_fbHmiBtnInbound : FB_HmiBtn;
	s_fbHmiBtnOutbound : FB_HmiBtn;
	s_fbHmiBtnDockTB : FB_HmiBtn;
	s_fbHmiBtnUndockTB : FB_HmiBtn;
	s_fbHmiBtnOpenInnerTBDoor : FB_HmiBtn;
	s_fbHmiBtnCloseInnerTBDoor : FB_HmiBtn;
	s_fbHmiBtnPickTrolleyFromTB : FB_HmiBtn;
	s_fbHmiBtnPlaceTrolleyInTB : FB_HmiBtn;
	
	s_bHmiForceOutputEnabled : BOOL;
	s_bHmiForceOutputRGBEnabled : BOOL;
	s_bHmiForceOutputWEnabled : BOOL;
	
END_VAR

VAR CONSTANT
	c_bBLINK : BOOL := TRUE;
	c_bON : BOOL := FALSE;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[
SUPER^();
]]></ST>
    </Implementation>
    <Method Name="_m_Alarms" Id="{c0f56159-8f50-4d36-acac-c259038873b1}">
      <Declaration><![CDATA[METHOD PROTECTED _m_Alarms : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT SUPER^._m_Alarms() THEN
	RETURN;
END_IF

//overbruggen in automode tot en met place table blablabla
s_errEmergencyBtn(
	i_bStaActive := NOT s_DiEmergencyBtn.p_bStaInput AND NOT GVL.g_fbHmiBtnSimulation.p_bStaBtn AND GVL.g_bConnectTestEquipment,
	i_eAlarmLevel := E_AlarmLevel.Alarm,
	i_sAlarmText := 'Emergency button pressed');

IF GVL_KMWEGenericLib.g_fbAlarmManager.p_bAlarmActive THEN
	GVL.g_eStaLedColor := E_KmweLedColors.Red;
END_IF

s_bStaError := s_errEmergencyBtn.q_bStaActive;

_m_Alarms := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Devices" Id="{68eeb98b-de01-4c23-9e4b-e0a75e4ed7ba}">
      <Declaration><![CDATA[METHOD PROTECTED _m_Devices : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT SUPER^._m_Devices() THEN
	RETURN;
END_IF

//Function blocks
s_fbFlashSlow(
	i_bExcecute := TRUE,
	t_tOnTime := T#1000MS,
	t_tOffTime := T#1000MS,
	o_bQ => GVL.g_bLedFlashSlow);
	
s_fbFlashFast(
	i_bExcecute := TRUE,
	t_tOnTime := T#500MS,
	t_tOffTime := T#500MS,
	o_bQ => GVL.g_bLedFlashFast);

//Control Modules

IF GVL.g_bFUMO3_Enabled THEN

	{warning '#FUMO3: Add conditions for air status in the future'}
	//Severity from high to low 
		//RED = Not Accesible, dirty air after opening outer cabin door 
		//MAGENTA = Not Accesible, dirty air after opening outer cabin door
		//BLUE = Pressurize (flash = busy, on = done)
		//CYAN = Flush (flash = busy, on = done)
		//YELLOW = Equalize (flash = busy, on = done)
		//GREEN = Accessible (flash = request pending, on = done)
		//WHITE = Worklight
	
	//Docking / Undocking
	
	//Error, not opertinal
	IF GVL_Modules.g_emAirTreatment.p_bStaStopped THEN
		s_cmCabinStateIndicator.m_Red(c_bBLINK);
	ELSIF FALSE (*_spare_*) THEN
		s_cmCabinStateIndicator.m_Red(c_bON);
		
	ELSIF ((s_eCabinAirState = E_AirState.UNKNOWN) OR (s_eCabinAirState = E_AirState.DIRTY))
		AND NOT(GVL_Modules.g_emDockingInterface.p_bStaDocked)
		AND NOT(GVL_Modules.g_emDockingInterface.p_bStaOuterDoorClosed) THEN
		s_cmCabinStateIndicator.m_Magenta(c_bBLINK);
		
	ELSIF (s_eCabinAirState = E_AirState.DIRTY) THEN
		s_cmCabinStateIndicator.m_Magenta(c_bON);
		
	//Spare
	ELSIF FALSE (*_spare_*) THEN
		s_cmCabinStateIndicator.m_Magenta(c_bBLINK);
	ELSIF FALSE (*_spare_*) THEN
		s_cmCabinStateIndicator.m_Magenta(c_bON);
		
	//Pressurize
	ELSIF FALSE (*_pressurizing_cabin_*) THEN
		s_cmCabinStateIndicator.m_Blue(c_bBLINK);
	ELSIF FALSE (*_cabin_pressurized_*) THEN
		s_cmCabinStateIndicator.m_Blue(c_bON);
		
	//Flush
	ELSIF FALSE (*_flushing_cabin_*) THEN
		s_cmCabinStateIndicator.m_Cyan(c_bBLINK);
	ELSIF FALSE (*_cabin_flushed_*) THEN
		s_cmCabinStateIndicator.m_Cyan(c_bON);
		
	//Equalize
	ELSIF FALSE (*_equalizing_cabin_*) THEN
		s_cmCabinStateIndicator.m_Yellow(c_bBLINK);
	ELSIF FALSE (*_cabin_equalized_*) THEN
		s_cmCabinStateIndicator.m_Yellow(c_bON);
		
	//Clean air
	ELSIF GVL_Modules.g_emAirTreatment.p_bStaClean
		AND NOT(s_cmDoorLockCleanroomDoor.p_bReqAccessRequest)
		AND NOT(s_cmDoorLockCleanroomDoor.p_bStaAccessGranted) THEN
		s_cmCabinStateIndicator.m_Green(c_bON);
		
	//Access Request Pending... wait for other modules are in the correct state
	ELSIF s_cmDoorLockCleanroomDoor.p_bReqAccessRequest THEN
		s_cmCabinStateIndicator.m_Green(c_bBLINK);
		
	//Access Granted (bright illumination)
	ELSIF s_cmDoorLockCleanroomDoor.p_bStaAccessGranted THEN
		s_cmCabinStateIndicator.m_White(c_bON);
	END_IF
	
	s_cmCabinStateIndicator(
		i_bFlashPulse := GVL.g_bLedFlashSlow,
		i_ref_eCtrlMode := s_eCtrlMode,
		i_ref_eCtrlState := s_eCtrlState);
		
	//Cleanroom Door Lock
	s_cmDoorLockCleanroomDoor.i_bAllowUnlock :=
		GVL_Modules.g_emLiftingTransport.p_bStaAtIdlePosition
		AND (GVL_Modules.g_emDockingInterface.p_bStaDocked
			OR GVL_Modules.g_emDockingInterface.p_bStaOuterDoorClosed);
		{warning '#FUMO3: Activate conditions below in future'}
		(*
		AND (GVL_Modules.g_emAirTreatment.p_bStaClean
			AND GVL_Modules.g_emAirTreatment.p_bStaEqualized);
		*)
	
	s_cmDoorLockCleanroomDoor(
		i_bReqEnable := TRUE,
		i_bFlashPulse := GVL.g_bLedFlashFast,
		i_eCtrlMode := s_eCtrlMode,
		i_ref_eCtrlState := s_eCtrlState,
		i_bCmdReset := p_bCmdReset OR s_fbHmiBtnReset.p_bStaBtn); //Add temp reset button
END_IF;

_m_Devices := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Hmi" Id="{6e489294-edbd-4c11-9b41-7f97eb3787da}">
      <Declaration><![CDATA[METHOD PROTECTED _m_Hmi : BOOL
VAR_INST
	s_sPrevPageAlarms 		: STRING;
	s_sPrevBottom1Alarms	: STRING;
	
	s_sCompanySelectionVisible	: STRING;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT SUPER^._m_Hmi() THEN
	RETURN;
END_IF

//--
(*
//Mode management
IF GVL_KMWEGenericLib.g_fbHmiBtnReturnToStart.p_osfBtnPress THEN
	s_eCtrlMode := E_CtrlMode.IDLE;
	
	GVL_KMWEGenericLib.g_fbHmiBtnAcknowledge.p_bStaVisible := TRUE;
	GVL_KMWEGenericLib.g_fbHmiBtnAcknowledge.p_bStaEnabled := TRUE;
END_IF
*)

//Alarm Button can always be pressed
IF s_fbHmiBtnAlarms.p_osrBtnPress AND GVL.g_sToHmiMiddleContent <> GVL.g_stHmiMiddle.AlarmManager THEN
	s_sPrevPageAlarms := GVL.g_sToHmiMiddleContent;
	s_sPrevBottom1Alarms := GvL.g_sToHmiBottomContent;
	GVL.g_sToHmiMiddleContent := GVL.g_stHmiMiddle.AlarmManager;
	GVL.g_sToHmiBottomContent := GVL.g_stHmiBottomBar.Alarm;
	
	GVL_KMWEGenericLib.g_fbHmiBtnReturn.p_bStaVisible := TRUE;
	GVL_KMWEGenericLib.g_fbHmiBtnReturn.p_bStaEnabled := TRUE;
END_IF

IF GVL.g_sToHmiMiddleContent = GVL.g_stHmiMiddle.AlarmManager AND GVL_KMWEGenericLib.g_fbHmiBtnReturn.p_osfBtnPress THEN
	GVL.g_sToHmiMiddleContent := s_sPrevPageAlarms;
	GVL.g_sToHmiBottomContent := s_sPrevBottom1Alarms;
	
	GVL_KMWEGenericLib.g_fbHmiBtnReturn.p_bStaVisible := FALSE;
	GVL_KMWEGenericLib.g_fbHmiBtnReturn.p_bStaEnabled := FALSE;
END_IF

//Hmi view management (General, Em can set module specific pages)
{warning #TODO: Check IF THIS can be used TO automatically open tab corresponding TO the selected mode}
CASE s_eCtrlMode OF
	E_CtrlMode.IDLE:
		GVL.g_sToHmiMiddleTab := 'General';
		
	E_CtrlMode.AUTOMATIC:
		GVL.g_sToHmiMiddleTab := 'AutoManual';
		
	E_CtrlMode.MANUAL:
		GVL.g_sToHmiMiddleTab := 'AutoManual';
		
	E_CtrlMode.MAINTENANCE:
		GVL.g_sToHmiMiddleTab := 'Maintenance';
		
	E_CtrlMode.IO:
		GVL.g_sToHmiMiddleTab := 'IO-Test';
		
	E_CtrlMode.CLEANING:
//++		GVL.g_sToHmiMiddleTab := 'Cleaning';
		
ELSE
		GVL.g_sToHmiMiddleTab := 'General';
END_CASE

//Hmi Buttons
s_fbHmiBtnAlarms();
s_fbHmiBtnReset();

s_fbHmiBtnInbound();
s_fbHmiBtnOutbound();
s_fbHmiBtnDockTB();
s_fbHmiBtnUndockTB();
s_fbHmiBtnOpenInnerTBDoor();
s_fbHmiBtnCloseInnerTBDoor();
s_fbHmiBtnPickTrolleyFromTB();
s_fbHmiBtnPlaceTrolleyInTB();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Init" Id="{71192b96-a840-4eae-8166-473534974241}">
      <Declaration><![CDATA[METHOD PROTECTED _m_Init : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT SUPER^._m_Init() THEN
	RETURN;
END_IF

//CM Config////////////////////////////////////////////////////////////////////////////////////////

IF GVL.g_bFUMO3_Enabled THEN
	//CM Cleanroom Door////////////////////////////////////////////////////////////////////////////////
	s_cmDoorLockCleanroomDoor.i_bReqEnable := FALSE;
	s_cmDoorLockCleanroomDoor.i_eCtrlMode := E_CtrlMode.IDLE;
	s_cmDoorLockCleanroomDoor.i_bCmdReset := FALSE;
	s_cmDoorLockCleanroomDoor.i_sCmName := 'CM Cleanroom Door';
	
	//CM Settings//////////////////////////////////////////////////////////////////////////////////////
	//CM Cleanroom Door////////////////////////////////////////////////////////////////////////////////
	s_cmDoorLockCleanroomDoor.i_stSettings.bAutoLockAtInit := TRUE;
	s_cmDoorLockCleanroomDoor.i_stSettings.tUnlockingRequestTimeout := T#30S;
END_IF

//EM Config////////////////////////////////////////////////////////////////////////////////////////
//EM Utilities/////////////////////////////////////////////////////////////////////////////////////
_m_AddModule(i_itfModuleBase := GVL_Modules.g_emUtilities);

GVL_Modules.g_emUtilities.i_bReqEnable := FALSE;
GVL_Modules.g_emUtilities.i_eCtrlMode := E_CtrlMode.IDLE;
GVL_Modules.g_emUtilities.i_bCmdReset := FALSE;
GVL_Modules.g_emUtilities.i_sEmName  := 'EM Utilities';

//EM Pallet Conveyor///////////////////////////////////////////////////////////////////////////////
_m_AddModule(i_itfModuleBase := GVL_Modules.g_emPalletConveyor);

GVL_Modules.g_emPalletConveyor.i_bReqEnable := FALSE;
GVL_Modules.g_emPalletConveyor.i_eCtrlMode := E_CtrlMode.IDLE;
GVL_Modules.g_emPalletConveyor.i_bCmdReset := FALSE;
GVL_Modules.g_emPalletConveyor.i_sEmName  := 'EM Pallet Conveyor';

//EM Docking Interface/////////////////////////////////////////////////////////////////////////////
_m_AddModule(i_itfModuleBase := GVL_Modules.g_emDockingInterface);

GVL_Modules.g_emDockingInterface.i_bReqEnable := FALSE;
GVL_Modules.g_emDockingInterface.i_eCtrlMode := E_CtrlMode.IDLE;
GVL_Modules.g_emDockingInterface.i_bCmdReset := FALSE;
GVL_Modules.g_emDockingInterface.i_sEmName  := 'EM Docking Interface';

//EM Lifting Transport/////////////////////////////////////////////////////////////////////////////
_m_AddModule(i_itfModuleBase := GVL_Modules.g_emLiftingTransport);

GVL_Modules.g_emLiftingTransport.i_bReqEnable := FALSE;
GVL_Modules.g_emLiftingTransport.i_eCtrlMode := E_CtrlMode.IDLE;
GVL_Modules.g_emLiftingTransport.i_bCmdReset := FALSE;
GVL_Modules.g_emLiftingTransport.i_sEmName := 'EM Lifting Transport';

//EM Doors/////////////////////////////////////////////////////////////////////////////////////////
//?? Inner- and Outer Cabin Door are moved to EM_DockingInterface
(*
_m_AddModule(i_itfModuleBase := GVL_Modules.g_emDoors);

GVL_Modules.g_emDoors.i_bReqEnable := FALSE;
GVL_Modules.g_emDoors.i_eCtrlMode := E_CtrlMode.IDLE;
GVL_Modules.g_emDoors.i_bCmdReset := FALSE;
GVL_Modules.g_emDoors.i_sEmName := 'EM Doors';
*)

//EM Air Treatment/////////////////////////////////////////////////////////////////////////////////

IF GVL.g_bFUMO3_Enabled THEN
	_m_AddModule(i_itfModuleBase := GVL_Modules.g_emAirTreatment);
	
	GVL_Modules.g_emAirTreatment.i_bReqEnable := FALSE;
	GVL_Modules.g_emAirTreatment.i_eCtrlMode := E_CtrlMode.IDLE;
	GVL_Modules.g_emAirTreatment.i_bCmdReset := FALSE;
	GVL_Modules.g_emAirTreatment.i_sEmName  := 'EM Air Treatment';
END_IF
	
//EM Interlocks////////////////////////////////////////////////////////////////////////////////////
//EM Utilities/////////////////////////////////////////////////////////////////////////////////////
//<none>

//EM Pallet Conveyor///////////////////////////////////////////////////////////////////////////////
//Conveyor
s_fbIlckHandlerConvBwd.i_stInterlockList.arr_Interlocks[0].sReason := 'Docking Clamps Not Opened';
s_fbIlckHandlerConvBwd.i_stInterlockList.arr_Interlocks[1].sReason := 'Unlocking Pins Not In';
s_fbIlckHandlerConvBwd.i_stInterlockList.arr_Interlocks[2].sReason := 'Door Opener Not Closed';

s_fbIlckHandlerConvFwd.i_stInterlockList.arr_Interlocks[0].sReason := 'Docking Clamps Not Opened';
s_fbIlckHandlerConvFwd.i_stInterlockList.arr_Interlocks[1].sReason := 'Unlocking Pins Not In';
s_fbIlckHandlerConvFwd.i_stInterlockList.arr_Interlocks[2].sReason := 'Door Opener Not Closed';
s_fbIlckHandlerConvFwd.i_stInterlockList.arr_Interlocks[3].sReason := 'Outer Cabin Door Not Opened';

//EM Docking Interface/////////////////////////////////////////////////////////////////////////////
s_fbIlckHandlerClampsToClose.i_stInterlockList.arr_Interlocks[0].sReason := '<n/a>';

s_fbIlckHandlerClampsToOpen.i_stInterlockList.arr_Interlocks[0].sReason := 'Cleanroom Door Not Closed';

//No external interlocks implemented for:
//	- DoorOpener
//	- DoorShutter
//	- Outer Cabin Door (open)
//	- Inner Cabin Door (open)

s_fbIlckHandlerOuterCabinDoorClose.i_stInterlockList.arr_Interlocks[0].sReason := 'TB At Docking Position';
s_fbIlckHandlerOuterCabinDoorClose.i_stInterlockList.arr_Interlocks[1].sReason := 'Lifting Transport Not At Idle Position';

s_fbIlckHandlerInnerCabinDoorClose.i_stInterlockList.arr_Interlocks[1].sReason := 'Lifting Transport Not At Idle Position';

//EM Lifting Transport/////////////////////////////////////////////////////////////////////////////
s_fbIlckHandlerTranportExtract.i_stInterlockList.arr_Interlocks[0].sReason := 'Door-Opener Not Opened';
s_fbIlckHandlerTranportExtract.i_stInterlockList.arr_Interlocks[1].sReason := 'Door-Shutter Not Opened';
s_fbIlckHandlerTranportExtract.i_stInterlockList.arr_Interlocks[2].sReason := 'Outer Cabin Door Is Not Opened';
s_fbIlckHandlerTranportExtract.i_stInterlockList.arr_Interlocks[3].sReason := 'Inner Cabin Door Is Not Opened';

//EM Doors

//EM Setting///////////////////////////////////////////////////////////////////////////////////////
//EM Utilities/////////////////////////////////////////////////////////////////////////////////////
//<none>

//EM Pallet Conveyor///////////////////////////////////////////////////////////////////////////////
GVL_Modules.g_emPalletConveyor.i_ref_stSettings REF= s_stSettings.stPalletConveyor;

//Transporting
s_stSettings.stPalletConveyor.fDistanceToInfeed := 1150.0; //[mm]
s_stSettings.stPalletConveyor.fDistanceToCentering := 980.0; //[mm]
s_stSettings.stPalletConveyor.fDistanceToDocking := 250.0; //[mm]
s_stSettings.stPalletConveyor.fDistanceOuterDoorCheck := 500.0; //[mm]
s_stSettings.stPalletConveyor.fTravelTollerance := 1.2; //[%] (1.20 = +20%)

//EM Docking Interface/////////////////////////////////////////////////////////////////////////////
GVL_Modules.g_emDockingInterface.i_ref_stSettings REF= s_stSettings.stDockingInterface;

//Docking
s_stSettings.stDockingInterface.tDelayNextStep := T#3S; //[s]

//EM Lifting Transport/////////////////////////////////////////////////////////////////////////////
GVL_Modules.g_emLiftingTransport.i_ref_stSettings REF= s_stSettings.stLiftingTransport;

//Homing
s_stSettings.stLiftingTransport.stSettingsServoLift.fHomeOffset := 5.00; //[mm]
s_stSettings.stLiftingTransport.stSettingsServoTransport.fHomeOffset := 0.00; //[mm]

//Stopping
s_stSettings.stLiftingTransport.stSettingsServoLift.fStopDec := 100.0; //[mm/s^2]
s_stSettings.stLiftingTransport.stSettingsServoLift.fStopJrk := 1000.0; //[mm/s^3]
s_stSettings.stLiftingTransport.stSettingsServoTransport.fStopDec := 100.0; //[mm/s^2]
s_stSettings.stLiftingTransport.stSettingsServoTransport.fStopJrk := 1000.0; //[mm/s^3]

//Mainteneance-mode:
//Jogging
s_stSettings.stLiftingTransport.stSettingsServoLift.fJogVel := 5.0; //[mm/s] (jog speed is configured in the NC-Task)
s_stSettings.stLiftingTransport.stSettingsServoLift.fJogAcc := 5.0; //[mm/s^2]
s_stSettings.stLiftingTransport.stSettingsServoLift.fJogDec := 5.0; //[mm/s^2]
s_stSettings.stLiftingTransport.stSettingsServoLift.fJogJrk := 50.0; //[mm/s^3]

s_stSettings.stLiftingTransport.stSettingsServoTransport.fJogVel := 5.0; //[mm/s] (jog speed is configured in the NC-Task)
s_stSettings.stLiftingTransport.stSettingsServoTransport.fJogAcc := 5.0; //[mm/s^2]
s_stSettings.stLiftingTransport.stSettingsServoTransport.fJogDec := 5.0; //[mm/s^2]
s_stSettings.stLiftingTransport.stSettingsServoTransport.fJogJrk := 50.0; //[mm/s^3]

//Positioning
s_stSettings.stLiftingTransport.stSettingsServoLift.fAbsPosPos := 5.0; //[mm]
s_stSettings.stLiftingTransport.stSettingsServoLift.fAbsPosVel := 10.0; //[mm/s]
s_stSettings.stLiftingTransport.stSettingsServoLift.fAbsPosAcc := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.stSettingsServoLift.fAbsPosDec := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.stSettingsServoLift.fAbsPosJrk := 100.0; //[mm/s^3]

s_stSettings.stLiftingTransport.stSettingsServoTransport.fAbsPosPos := 0.0; //[mm]
s_stSettings.stLiftingTransport.stSettingsServoTransport.fAbsPosVel := 10.0; //[mm/s]
s_stSettings.stLiftingTransport.stSettingsServoTransport.fAbsPosAcc := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.stSettingsServoTransport.fAbsPosDec := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.stSettingsServoTransport.fAbsPosJrk := 100.0; //[mm/s^3]

//Manual- and Automatic-mode, Positioning
//[0] = Idle
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[0].fPos := 0.0; //[mm]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[0].fVel := 10.0; //[mm/s]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[0].fAcc := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[0].fDec := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[0].fJrk := 100.0; //[mm/s^3]

//[1] = Pre Pick From TB
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[1].fPos := 306.01; //[mm]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[1].fVel := 10.01; //[mm/s]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[1].fAcc := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[1].fDec := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[1].fJrk := 100.0; //[mm/s^3]

//[2] = Pick From TB
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[2].fPos := 331.02; //[mm]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[2].fVel := 5.02; //[mm/s]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[2].fAcc := 5.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[2].fDec := 5.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[2].fJrk := 50.0; //[mm/s^3]

//[3] = Raise From TB
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[3].fPos := 404.03; //[mm]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[3].fVel := 10.03; //[mm/s]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[3].fAcc := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[3].fDec := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[3].fJrk := 100.0; //[mm/s^3]

//[4] = Pre Place In Cabin
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[4].fPos := 45.04; //[mm]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[4].fVel := 10.04; //[mm/s]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[4].fAcc := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[4].fDec := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[4].fJrk := 100.0; //[mm/s^3]

//[5] = Place In Cabin
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[5].fPos := 0.05; //[mm]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[5].fVel := 5.05; //[mm/s]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[5].fAcc := 5.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[5].fDec := 5.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[5].fJrk := 50.0; //[mm/s^3]

//[6] = Pre Pick From Cabin
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[6].fPos := 10.06; //[mm]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[6].fVel := 10.06; //[mm/s]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[6].fAcc := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[6].fDec := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[6].fJrk := 10.0; //[mm/s^3]

//[7] = Pick From Cabin
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[7].fPos := 45.07; //[mm]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[7].fVel := 5.07; //[mm/s]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[7].fAcc := 5.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[7].fDec := 5.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[7].fJrk := 50.0; //[mm/s^3]

//[8] = Raise From Cabin
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[8].fPos := 404.08; //[mm]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[8].fVel := 10.08; //[mm/s]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[8].fAcc := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[8].fDec := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[8].fJrk := 100.0; //[mm/s^3]

//[9] = Pre Place In TB
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[9].fPos := 374.09; //[mm]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[9].fVel := 10.09; //[mm/s]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[9].fAcc := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[9].fDec := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[9].fJrk := 100.0; //[mm/s^3]

//[10] = Place In TB
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[10].fPos := 331.10; //[mm]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[10].fVel := 10.10; //[mm/s]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[10].fAcc := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[10].fDec := 10.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stLiftPositioningProfile[10].fJrk := 100.0; //[mm/s^3]

//Automatic-Positioning Transport//////////////////////////////////////////////////////////////////
//[0] = Idle
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[0].fPos := 0.0; //[mm]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[0].fVel := 100.0; //[mm/s]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[0].fAcc := 100.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[0].fDec := 100.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[0].fJrk := 1000.0; //[mm/s^3]

//[1] = Pre Pick From TB
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[1].fPos := 1690.01; //[mm]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[1].fVel := 200.02; //[mm/s]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[1].fAcc := 200.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[1].fDec := 200.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[1].fJrk := 2000.0; //[mm/s^3]

//[2] = Pick From TB
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[2].fPos := 1715.02; //[mm]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[2].fVel := 20.04; //[mm/s]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[2].fAcc := 20.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[2].fDec := 20.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[2].fJrk := 200.0; //[mm/s^3]

//[3] = Place In Cabin
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[3].fPos := 0.03; //[mm]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[3].fVel := 200.06; //[mm/s]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[3].fAcc := 200.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[3].fDec := 200.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[3].fJrk := 2000.0; //[mm/s^3]

//[4] = Pre Place In TB
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[4].fPos := 1690.04; //[mm]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[4].fVel := 200.08; //[mm/s]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[4].fAcc := 200.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[4].fDec := 200.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[4].fJrk := 2000.0; //[mm/s^3]

//[5] = Place In TB
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[5].fPos := 1710.05; //[mm]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[5].fVel := 20.10; //[mm/s]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[5].fAcc := 20.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[5].fDec := 20.0; //[mm/s^2]
s_stSettings.stLiftingTransport.arr_stTransportPositioningProfile[5].fJrk := 200.0; //[mm/s^3]

//EM Doors
//Settings Doors

//?? Inner- and Outer Cabin Door are moves to EM_DockingInterface
(*
GVL_Modules.g_emDoors.i_ref_stSettings REF= s_stSettings.stSettingsDoors;

GVL_Modules.g_emDoors.i_ref_stSettings.tOuterDoorTimeout := T#15S;
GVL_Modules.g_emDoors.i_ref_stSettings.tInnerDoorTimeout := T#15S;
GVL_Modules.g_emDoors.i_ref_stSettings.tCleanroomDoorTimeout := T#3S;
GVL_Modules.g_emDoors.i_ref_stSettings.tResetPulseDuration := T#1S;
*)

(* ++
_m_AddModule(i_itfModuleBase := GVL_Modules.g_emDockingCabin);

GVL_Modules.g_emDockingCabin.i_bReqEnable := FALSE;
GVL_Modules.g_emDockingCabin.i_eCtrlMode := E_CtrlMode.IDLE;
GVL_Modules.g_emDockingCabin.i_bCmdReset := FALSE;
GVL_Modules.g_emDockingCabin.i_sEmName  := 'EM State Machine';

//Settings Doors
GVL_Modules.g_emDockingCabin.i_stSettings.stSettingsDoors.tOuterDoorTimeout := T#15S;
GVL_Modules.g_emDockingCabin.i_stSettings.stSettingsDoors.tCleanroomDoorTimeout := T#3S;
GVL_Modules.g_emDockingCabin.i_stSettings.stSettingsDoors.tResetPulseDuration := T#1S;
*)

//Settings AirTreatment
//EM Air Treatment/////////////////////////////////////////////////////////////////////////////////

IF GVL.g_bFUMO3_Enabled THEN
	GVL_Modules.g_emAirTreatment.i_ref_stSettings REF= s_stSettings.stAirTreatment;
	
	//Pressure controller 
	s_stSettings.stAirTreatment.fKp := -1.0; //P [factor]
	s_stSettings.stAirTreatment.fTn := 10.0; //I [s]
	s_stSettings.stAirTreatment.fTv := 0.0; //D [s]
	s_stSettings.stAirTreatment.fTd := 0.0; //D-time [s]
END_IF
	
//Hmi//////////////////////////////////////////////////////////////////////////////////////////////

//Startup
GVL.g_sToHmiTopContent := GVL.g_stHmiTopBar.GeneralTopbar;
GVL.g_sToHmiMiddleContent := GVL.g_stHmiMiddle.Start;
GVL.g_sToHmiBottomContent := GVL.g_stHmiBottomBar.Start;
GVL.g_sToHmiMiddleTab := 'General';

//Buttons
s_fbHmiBtnAlarms.p_bStaVisible := TRUE;
s_fbHmiBtnAlarms.p_bStaEnabled := TRUE;
s_fbHmiBtnAlarms.p_eButtontype := E_HmiButtonType.PUSHBUTTON;
s_fbHmiBtnAlarms.p_sBtnText := 'Alarms';

s_fbHmiBtnReset.p_bStaVisible := TRUE;
s_fbHmiBtnReset.p_bStaEnabled := TRUE;
s_fbHmiBtnReset.p_eButtontype := E_HmiButtonType.PUSHBUTTON;
s_fbHmiBtnReset.p_sBtnText := 'Reset';

s_fbHmiBtnInbound.p_bStaVisible := TRUE;
s_fbHmiBtnInbound.p_bStaEnabled := TRUE;
s_fbHmiBtnInbound.p_eButtontype := E_HmiButtonType.PUSHBUTTON;
s_fbHmiBtnInbound.p_sBtnText := 'Inbound';

s_fbHmiBtnOutbound.p_bStaVisible := TRUE;
s_fbHmiBtnOutbound.p_bStaEnabled := TRUE;
s_fbHmiBtnOutbound.p_eButtontype := E_HmiButtonType.PUSHBUTTON;
s_fbHmiBtnOutbound.p_sBtnText := 'Outbound';

s_fbHmiBtnDockTB.p_bStaVisible := TRUE;
s_fbHmiBtnDockTB.p_bStaEnabled := TRUE;
s_fbHmiBtnDockTB.p_eButtontype := E_HmiButtonType.PUSHBUTTON;
s_fbHmiBtnDockTB.p_sBtnText := 'Dock TB';

s_fbHmiBtnUndockTB.p_bStaVisible := TRUE;
s_fbHmiBtnUndockTB.p_bStaEnabled := TRUE;
s_fbHmiBtnUndockTB.p_eButtontype := E_HmiButtonType.PUSHBUTTON;
s_fbHmiBtnUndockTB.p_sBtnText := 'Undock TB';

s_fbHmiBtnOpenInnerTBDoor.p_bStaVisible := TRUE;
s_fbHmiBtnOpenInnerTBDoor.p_bStaEnabled := TRUE;
s_fbHmiBtnOpenInnerTBDoor.p_eButtontype := E_HmiButtonType.PUSHBUTTON;
s_fbHmiBtnOpenInnerTBDoor.p_sBtnText := 'Open Inner TB Door';

s_fbHmiBtnCloseInnerTBDoor.p_bStaVisible := TRUE;
s_fbHmiBtnCloseInnerTBDoor.p_bStaEnabled := TRUE;
s_fbHmiBtnCloseInnerTBDoor.p_eButtontype := E_HmiButtonType.PUSHBUTTON;
s_fbHmiBtnCloseInnerTBDoor.p_sBtnText := 'Close Inner TB Door';

s_fbHmiBtnPickTrolleyFromTB.p_bStaVisible := TRUE;
s_fbHmiBtnPickTrolleyFromTB.p_bStaEnabled := TRUE;
s_fbHmiBtnPickTrolleyFromTB.p_eButtontype := E_HmiButtonType.PUSHBUTTON;
s_fbHmiBtnPickTrolleyFromTB.p_sBtnText := 'Pick Trolley From TB';

s_fbHmiBtnPlaceTrolleyInTB.p_bStaVisible := TRUE;
s_fbHmiBtnPlaceTrolleyInTB.p_bStaEnabled := TRUE;
s_fbHmiBtnPlaceTrolleyInTB.p_eButtontype := E_HmiButtonType.PUSHBUTTON;
s_fbHmiBtnPlaceTrolleyInTB.p_sBtnText := 'Place Trolley In TB';

GVL_KMWEGenericLib.g_fbHmiBtnReturn.p_bStaVisible := FALSE;
GVL_KMWEGenericLib.g_fbHmiBtnReturn.p_bStaEnabled := FALSE;

//??s_diTwoHandControl.i_stSettings.tmInputDelay := T#2S;

_m_Init := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Modules" Id="{2372c80a-8810-4c92-8500-979916e08046}">
      <Declaration><![CDATA[METHOD PROTECTED _m_Modules : BOOL
VAR
	bReqEnable : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
s_fbModeStateControl(
	i_bReqStopAlarm :=
		(
			GVL_Modules.g_emUtilities.p_bStaError
			OR GVL_Modules.g_emPalletConveyor.p_bStaError
			OR GVL_Modules.g_emDockingInterface.p_bStaError
			OR GVL_Modules.g_emLiftingTransport.p_bStaError
			OR GVL_Modules.g_emAirTreatment.p_bStaError
		)
		AND	( (s_eCtrlMode = E_CtrlMode.AUTOMATIC) OR (s_eCtrlMode = E_CtrlMode.MANUAL) ),
	i_bStaAllStopped := TRUE);

s_eCtrlMode := s_fbModeStateControl.p_eCtrlMode;
s_eCtrlState :=	s_fbModeStateControl.p_eCtrlState;

//EM_Utilities/////////////////////////////////////////////////////////////////////////////////////
GVL_Modules.g_emUtilities.m_GetGeneralState(
	i_bError := s_bStaError,
	i_bWarning := s_bStaWarning,
	i_bRunning := s_bStaRunning);
	
GVL_Modules.g_emUtilities(
	i_bReqEnable := TRUE,
	i_eCtrlMode := s_eCtrlMode,
	i_eCtrlState := s_eCtrlState,
	i_bCmdReset := p_bCmdReset OR s_fbHmiBtnReset.p_bStaBtn); //Add temp reset button
	
bReqEnable :=
	GVL_Modules.g_emUtilities.p_bStaSafetyOk
	AND GVL_Modules.g_emUtilities.p_bStsPowerOk
	AND GVL_Modules.g_emUtilities.p_bStaAirPressureOk
	AND NOT GVL_Modules.g_emUtilities.p_bStaError;
	
//EM_PalletConveyor////////////////////////////////////////////////////////////////////////////////
//Interlocks
s_fbIlckHandlerConvBwd.i_stInterlockList.arr_Interlocks[0].bState := NOT(GVL_Modules.g_emDockingInterface.p_bStaClampsOpened) AND GVL_Modules.g_emPalletConveyor.p_bStaTB_AtDocking;
s_fbIlckHandlerConvBwd.i_stInterlockList.arr_Interlocks[1].bState := NOT(GVL_Modules.g_emDockingInterface.p_bStaUnlockPinsLocked) AND GVL_Modules.g_emPalletConveyor.p_bStaTB_AtDocking;
s_fbIlckHandlerConvBwd.i_stInterlockList.arr_Interlocks[2].bState := NOT(GVL_Modules.g_emDockingInterface.p_bStaDoorOpenerClosed) AND GVL_Modules.g_emPalletConveyor.p_bStaTB_AtDocking;
s_fbIlckHandlerConvBwd();

s_fbIlckHandlerConvFwd.i_stInterlockList.arr_Interlocks[0].bState := NOT(GVL_Modules.g_emDockingInterface.p_bStaClampsOpened) AND GVL_Modules.g_emPalletConveyor.p_bStaTB_AtCentering;
s_fbIlckHandlerConvFwd.i_stInterlockList.arr_Interlocks[1].bState := NOT(GVL_Modules.g_emDockingInterface.p_bStaUnlockPinsLocked) AND GVL_Modules.g_emPalletConveyor.p_bStaTB_AtCentering;
s_fbIlckHandlerConvFwd.i_stInterlockList.arr_Interlocks[2].bState := NOT(GVL_Modules.g_emDockingInterface.p_bStaDoorOpenerClosed) AND GVL_Modules.g_emPalletConveyor.p_bStaTB_AtCentering;
s_fbIlckHandlerConvFwd.i_stInterlockList.arr_Interlocks[3].bState := NOT(GVL_Modules.g_emDockingInterface.p_bStaOuterDoorOpened) AND GVL_Modules.g_emPalletConveyor.p_bStaTB_AtCentering AND GVL.g_bFUMO3_Enabled;
s_fbIlckHandlerConvFwd();

GVL_Modules.g_emPalletConveyor(
	i_bReqEnable := bReqEnable,
	i_eCtrlMode := s_eCtrlMode,
	i_eCtrlState := s_eCtrlState,
	i_bCmdReset := p_bCmdReset OR s_fbHmiBtnReset.p_bStaBtn, //Add temp reset button
	i_stExtIlckConvFwd := s_fbIlckHandlerConvFwd.p_stInterlock,
	i_stExtIlckConvBwd := s_fbIlckHandlerConvBwd.p_stInterlock);
	
//EM_DockingInterface//////////////////////////////////////////////////////////////////////////////
//Interlocks
s_fbIlckHandlerClampsToClose.i_stInterlockList.arr_Interlocks[0].bState := FALSE; //none
s_fbIlckHandlerClampsToClose();

{warning '#FUMO3: ADD cleanroom door status'}
s_fbIlckHandlerClampsToOpen.i_stInterlockList.arr_Interlocks[0].bState := FALSE; //++ NOT(GVL_Modules.g_emDoors.p_bStaCleanroomDoorNotClosedAndLocked);
s_fbIlckHandlerClampsToOpen();

IF GVL.g_bFUMO3_Enabled THEN
	s_fbIlckHandlerOuterCabinDoorClose.i_stInterlockList.arr_Interlocks[0].bState := GVL_Modules.g_emPalletConveyor.p_bStaTB_AtDocking;
	s_fbIlckHandlerOuterCabinDoorClose.i_stInterlockList.arr_Interlocks[1].bState := NOT(GVL_Modules.g_emLiftingTransport.p_bStaAtIdlePosition);
	s_fbIlckHandlerOuterCabinDoorClose();
	
	s_fbIlckHandlerInnerCabinDoorClose.i_stInterlockList.arr_Interlocks[0].bState := NOT(GVL_Modules.g_emLiftingTransport.p_bStaAtIdlePosition);
	s_fbIlckHandlerInnerCabinDoorClose();
END_IF

GVL_Modules.g_emDockingInterface(
	i_bTestDisableCabinDoors := NOT(GVL.g_bFUMO3_Enabled),
	i_bReqEnable := bReqEnable,
	i_eCtrlMode := s_eCtrlMode,
	i_eCtrlState := s_eCtrlState,
	i_bCmdReset := p_bCmdReset OR s_fbHmiBtnReset.p_bStaBtn, //Add temp reset button
	i_bStaTbAtDockingPosition := GVL_Modules.g_emPalletConveyor.p_bStaTB_ReadyForDocking,
	i_bStaDockingPositionFree := GVL_Modules.g_emPalletConveyor.p_bStaTB_DockPosFree,
	i_stExtIlckDockingClampsToOpen := s_fbIlckHandlerClampsToOpen.p_stInterlock,
	i_stExtIlckDockingClampsToClose := s_fbIlckHandlerClampsToClose.p_stInterlock,
	i_stExtIlckOuterCabinDoorToClose := s_fbIlckHandlerOuterCabinDoorClose.p_stInterlock,
	i_stExtIlckInnerCabinDoorToClose := s_fbIlckHandlerInnerCabinDoorClose.p_stInterlock);
	
//EM_LiftingTransport//////////////////////////////////////////////////////////////////////////////
s_fbIlckHandlerTranportExtract.i_stInterlockList.arr_Interlocks[0].bState := NOT(GVL_Modules.g_emDockingInterface.p_bStaDoorOpenerOpened);
s_fbIlckHandlerTranportExtract.i_stInterlockList.arr_Interlocks[1].bState := NOT(GVL_Modules.g_emDockingInterface.p_bStaDoorShutterOpened);
s_fbIlckHandlerTranportExtract.i_stInterlockList.arr_Interlocks[2].bState := NOT(GVL_Modules.g_emDockingInterface.p_bStaOuterDoorOpened) AND GVL.g_bFUMO3_Enabled;
s_fbIlckHandlerTranportExtract.i_stInterlockList.arr_Interlocks[3].bState := NOT(GVL_Modules.g_emDockingInterface.p_bStaInnerDoorOpened) AND GVL.g_bFUMO3_Enabled;
s_fbIlckHandlerTranportExtract();

GVL_Modules.g_emLiftingTransport(
	i_bReqEnable := bReqEnable,
	i_eCtrlMode := s_eCtrlMode,
	i_eCtrlState := s_eCtrlState,
	i_bCmdReset := p_bCmdReset OR s_fbHmiBtnReset.p_bStaBtn, //Add temp reset button
	i_stExtIlckTransportExtract := s_fbIlckHandlerTranportExtract.p_stInterlock);

(*
//EM_Doors/////////////////////////////////////////////////////////////////////////////////////////
	
GVL_Modules.g_emDoors(
	i_bReqEnable := TRUE,
	i_eCtrlMode := s_eCtrlMode,
	i_eCtrlState := s_eCtrlState,
	i_bCmdReset := p_bCmdReset OR s_fbHmiBtnReset.p_bStaBtn, //Add temp reset button
	i_bStaInfeedSealed := GVL_Modules.g_emPalletConveyor.p_bStaTB_AtDocking AND GVL_Modules.g_emDockingInterface.p_bStaDocked,
	i_sEmName := 'EM Doors',
	i_ref_objCarrier := GVL_Modules.g_objCarrier,
	i_fbExtIlckOuterDoorOpen := s_fbExtIlckOuterCabinDoorOpen,
	i_fbExtIlckOuterDoorClose := s_fbExtIlckOuterCabinDoorClose,
	i_fbExtIlckInnerDoorOpen := s_fbExtIlckInnerCabinDoorOpen,
	i_fbExtIlckInnerDoorClose := s_fbExtIlckInnerCabinDoorClose);
*)

//EM_AirTreatment//////////////////////////////////////////////////////////////////////////////////
//Interlocks
//<none>
IF GVL.g_bFUMO3_Enabled THEN
	GVL_Modules.g_emAirTreatment(
		i_bReqEnable := bReqEnable,
		i_eCtrlMode := s_eCtrlMode,
		i_eCtrlState := s_eCtrlState,
		i_bCmdReset:= p_bCmdReset OR s_fbHmiBtnReset.p_bStaBtn); //Add temp reset button
END_IF

s_bStaError :=
	GVL_Modules.g_emUtilities.q_bStaError
	OR GVL_Modules.g_emPalletConveyor.q_bStaError
	OR GVL_Modules.g_emDockingInterface.q_bStaError
	OR GVL_Modules.g_emLiftingTransport.q_bStaError
	OR GVL_Modules.g_emAirTreatment.q_bStaError
	OR s_cmDoorLockCleanroomDoor.p_bStaError;
//++	OR GVL_Modules.g_emDoors.q_bStaError;
//++OR GVL_Modules.g_emDockingCabin.q_bStaError

s_bStaWarning :=
	GVL_Modules.g_emUtilities.q_bStaWarning
	OR GVL_Modules.g_emPalletConveyor.q_bStaWarning
	OR GVL_Modules.g_emDockingInterface.q_bStaWarning
	OR GVL_Modules.g_emLiftingTransport.q_bStaWarning
	OR GVL_Modules.g_emAirTreatment.q_bStaWarning
	OR s_cmDoorLockCleanroomDoor.p_bStaWarning;
//++	OR GVL_Modules.g_emDoors.q_bStaWarning;
//++OR GVL_Modules.g_emDockingCabin.q_bStaWarning

_m_Modules := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Sequence" Id="{90534ebe-9d21-4aeb-b2cc-cf785c67a06d}">
      <Declaration><![CDATA[METHOD PROTECTED _m_Sequence : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//Register previous step
IF s_eSequence <> s_ePreviousStep
	AND s_eSequence <> E_SeqCleanroomConnect.ERROR THEN
	s_ePreviousStep := s_eSequence;
END_IF

s_bStaEmError :=
	GVL_Modules.g_emPalletConveyor.p_bStaError
	OR GVL_Modules.g_emDockingInterface.p_bStaError
	OR GVL_Modules.g_emLiftingTransport.p_bStaError
	OR GVL_Modules.g_emAirTreatment.p_bStaError;
	
s_fbSeqControl(
	i_nSeqStep := s_eSequence,
	i_sStepName := TO_STRING(s_eSequence),
	i_bCmdReset := s_fbHmiBtnReset.p_bStaBtn,
	i_bStaError := s_bStaEmError);
	
s_tonTimer(PT := T#3600S);

//Force to stop
IF (s_eCtrlState = E_CtrlState.STOPPING) THEN
	s_eSequence := E_SeqCleanroomConnect.STOP;
END_IF

s_sResumeStep := TO_STRING(s_eResumeStep);

CASE s_eSequence OF
	E_SeqCleanroomConnect.IDLE:
		s_eCabinAirState := E_AirState.UNKNOWN;
		s_eResumeStep := E_SeqCleanroomConnect.READY;
		s_eSequence := E_SeqCleanroomConnect.START;
		
	E_SeqCleanroomConnect.START:
		IF s_eCtrlState = E_CtrlState.RUNNING THEN
			s_eSequence := s_eResumeStep;
		END_IF
		
////READY//////////////////////////////////////////////////////////////////////////////////////////
	E_SeqCleanroomConnect.READY:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_eResumeStep := E_SeqCleanroomConnect.READY;
			s_eReqAction := E_ReqAction.NONE;
		END_IF
		
		//Return to START
		IF s_eCtrlState <> E_CtrlState.RUNNING THEN
			s_eSequence := E_SeqCleanroomConnect.START;
		END_IF
		
		//Via seperate commands te steps below can be initiated, depanding on a certain value the next command can be strated automatically.
		;
		
		//Check if all equipment is ready (available for operation)
		s_bStaAllEmReady :=
			GVL_Modules.g_emPalletConveyor.p_bStaReady AND
			GVL_Modules.g_emDockingInterface.p_bStaReady AND
			GVL_Modules.g_emLiftingTransport.p_bStaReady;
			
		//REQUEST DOCK TB//////////////////////////////////////////////////////////////////////////
		IF s_bStaAllEmReady
			AND ( (s_eReqAction = E_ReqAction.INBOUND)
			OR (s_eReqAction = E_ReqAction.OUTBOUND)
			OR (s_eReqAction = E_ReqAction.DOCK_TB) ) THEN
				s_eSequence := E_SeqCleanroomConnect.TB_TO_CENTER;
				
		//REQUEST UNDOCK TB////////////////////////////////////////////////////////////////////////
		ELSIF s_bStaAllEmReady
			AND (s_eReqAction = E_ReqAction.UNDOCK_TB) THEN
				s_eSequence := E_SeqCleanroomConnect.UNDOCK_TB;
				
		//REQUEST OPEN INNER TB DOOR///////////////////////////////////////////////////////////////
		ELSIF s_bStaAllEmReady
			AND (s_eReqAction = E_ReqAction.OPEN_INNER_TB_DOOR) THEN
				s_eSequence := E_SeqCleanroomConnect.OPEN_INNER_TB_DOOR;
				
		//REQUEST CLOSE INNER TB DOOR//////////////////////////////////////////////////////////////
		ELSIF s_bStaAllEmReady
			AND (s_eReqAction = E_ReqAction.CLOSE_INNER_TB_DOOR) THEN
				s_eSequence := E_SeqCleanroomConnect.CLOSE_INNER_TB_DOOR;
				
		//REQUEST PICK TROLLEY FROM TB/////////////////////////////////////////////////////////////
		ELSIF s_bStaAllEmReady
			AND (s_eReqAction = E_ReqAction.PICK_TROLLEY_FROM_TB) THEN
				s_eSequence := E_SeqCleanroomConnect.PICK_TROLLEY_FROM_TB;
				
		//REQUEST PLACE TROLLEY IN TB//////////////////////////////////////////////////////////////
		ELSIF s_bStaAllEmReady
			AND (s_eReqAction = E_ReqAction.PLACE_TROLLEY_IN_TB) THEN
				s_eSequence := E_SeqCleanroomConnect.PLACE_TROLLEY_IN_TB;
		END_IF
		
	//DOCK TB//////////////////////////////////////////////////////////////////////////////////////
	E_SeqCleanroomConnect.TB_TO_CENTER:
		IF s_fbSeqControl.q_bStaEntry THEN
			GVL_Modules.g_emPalletConveyor.m_ReqTB_ToCenter();
		END_IF
		
		IF GVL_Modules.g_emPalletConveyor.p_bStaTB_AtCentering
			AND GVL_Modules.g_emPalletConveyor.p_bStaReady THEN
			s_eSequence := E_SeqCleanroomConnect.START_DOCK_TB;
		END_IF
		
	E_SeqCleanroomConnect.START_DOCK_TB:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_eCabinAirState := E_AirState.DIRTY;
			GVL_Modules.g_emDockingInterface.m_ReqDockTB();
		END_IF
		
		IF GVL_Modules.g_emDockingInterface.p_bStsReadyToReceiveTB THEN
			s_eSequence := E_SeqCleanroomConnect.TB_TO_DOCKING;
		END_IF
		
	E_SeqCleanroomConnect.TB_TO_DOCKING:
		IF s_fbSeqControl.q_bStaEntry THEN
			GVL_Modules.g_emPalletConveyor.m_ReqTB_ToDocking();
		END_IF
		
		IF GVL_Modules.g_emPalletConveyor.p_bStaTB_ReadyForDocking
			AND GVL_Modules.g_emPalletConveyor.p_bStaReady THEN
				s_eSequence := E_SeqCleanroomConnect.FINISH_DOCK_TB;
		END_IF
		
 	E_SeqCleanroomConnect.FINISH_DOCK_TB:
		IF s_fbSeqControl.q_bStaEntry THEN
			GVL_Modules.g_emDockingInterface.m_ReqDockTB();
		END_IF
		
		IF GVL_Modules.g_emDockingInterface.p_bStaDocked
			AND GVL_Modules.g_emDockingInterface.p_bStaReady THEN
				
				IF ( (s_eReqAction = E_ReqAction.INBOUND) OR (s_eReqAction = E_ReqAction.OUTBOUND) ) THEN
					s_eSequence := E_SeqCleanroomConnect.OPEN_INNER_TB_DOOR;
				ELSE
					s_bStaDockTbDone := TRUE;
					s_bStaUnDockTbDone := FALSE;
					s_bStaOpenInnerTbDoorDone := FALSE;
					s_bStaCloseInnerTbDoorDone := FALSE;
					s_bStaPickTrolleyFromTbDone := FALSE;
					s_bStaPlaceTrolleyInTbDone := FALSE;
					
					s_eSequence := E_SeqCleanroomConnect.READY;
				END_IF
		END_IF
		
	//UNDOCK TB////////////////////////////////////////////////////////////////////////////////////
	E_SeqCleanroomConnect.UNDOCK_TB:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_eCabinAirState := E_AirState.DIRTY;
			GVL_Modules.g_emDockingInterface.m_ReqUndockTB();
		END_IF
		
		IF GVL_Modules.g_emDockingInterface.p_bStaClampsOpened THEN
			s_eSequence := E_SeqCleanroomConnect.TB_TO_INFEED;
		END_IF
		
	E_SeqCleanroomConnect.TB_TO_INFEED:
		IF s_fbSeqControl.q_bStaEntry THEN
			GVL_Modules.g_emPalletConveyor.m_ReqTB_ToInfeed();
		END_IF
		
		s_osrReqDockTb(CLK := GVL_Modules.g_emPalletConveyor.p_bStaTB_DockPosFree);
		
		IF s_osrReqDockTb.Q THEN
			GVL_Modules.g_emDockingInterface.m_ReqUndockTB();
		END_IF
		
		IF GVL_Modules.g_emPalletConveyor.p_bStaTB_AtInfeed
			AND GVL_Modules.g_emPalletConveyor.p_bStaReady
			AND GVL_Modules.g_emDockingInterface.p_bStaUndocked
			AND GVL_Modules.g_emDockingInterface.p_bStaReady THEN
				s_bStaDockTbDone := FALSE;
				s_bStaUnDockTbDone := TRUE;
				s_bStaOpenInnerTbDoorDone := FALSE;
				s_bStaCloseInnerTbDoorDone := FALSE;
				s_bStaPickTrolleyFromTbDone := FALSE;
				s_bStaPlaceTrolleyInTbDone := FALSE;
				
				s_eSequence := E_SeqCleanroomConnect.READY;
		END_IF
		
	//OPEN INNER TB DOOR///////////////////////////////////////////////////////////////////////////
	E_SeqCleanroomConnect.OPEN_INNER_TB_DOOR:
		IF s_fbSeqControl.q_bStaEntry THEN
			GVL_Modules.g_emDockingInterface.m_ReqOpenInnerDoor();
		END_IF
		
		IF GVL_Modules.g_emDockingInterface.p_bStaInnerDoorOpened
			AND GVL_Modules.g_emDockingInterface.p_bStaReady THEN
			
			IF GVL.g_bFUMO3_Enabled THEN
				s_eSequence := E_SeqCleanroomConnect.FLUSHING;
			ELSE
				s_eSequence := E_SeqCleanroomConnect.READY;
			END_IF
		END_IF
		
	E_SeqCleanroomConnect.FLUSHING:
		IF s_fbSeqControl.q_tmStepTime > T#5S THEN
			s_eCabinAirState := E_AirState.CLEAN;
			
			{warning '#FUMO3: Add future/FUMO3 code'}
			IF ( (s_eReqAction = E_ReqAction.INBOUND) (*OR (s_eReqAction = E_ReqAction.PICK_TROLLEY_FROM_TB)*) ) THEN
				s_eSequence := E_SeqCleanroomConnect.PICK_TROLLEY_FROM_TB;
			ELSIF ( (s_eReqAction = E_ReqAction.OUTBOUND) OR (s_eReqAction = E_ReqAction.PLACE_TROLLEY_IN_TB) ) THEN
				s_eSequence := E_SeqCleanroomConnect.OPEN_CLEANROOM_DOOR;
			ELSE
				s_bStaDockTbDone := FALSE;
				s_bStaUnDockTbDone := FALSE;
				s_bStaOpenInnerTbDoorDone := TRUE;
				s_bStaCloseInnerTbDoorDone := FALSE;
				s_bStaPickTrolleyFromTbDone := FALSE;
				s_bStaPlaceTrolleyInTbDone := FALSE;
				
				s_eSequence := E_SeqCleanroomConnect.READY;
			END_IF
		END_IF
		
	//CLOSE INNER TB DOOR//////////////////////////////////////////////////////////////////////////
	E_SeqCleanroomConnect.CLOSE_INNER_TB_DOOR:
		IF s_fbSeqControl.q_bStaEntry THEN
			GVL_Modules.g_emDockingInterface.m_ReqCloseInnerDoor();
		END_IF
		
		IF GVL_Modules.g_emDockingInterface.p_bStaInnerDoorClosed
			AND GVL_Modules.g_emDockingInterface.p_bStaReady THEN
				s_bStaDockTbDone := FALSE;
				s_bStaUnDockTbDone := FALSE;
				s_bStaOpenInnerTbDoorDone := FALSE;
				s_bStaCloseInnerTbDoorDone := TRUE;
				s_bStaPickTrolleyFromTbDone := FALSE;
				s_bStaPlaceTrolleyInTbDone := FALSE;
				
				IF GVL_Modules.g_emDockingInterface.p_bStaReady THEN
					
					IF ( (s_eReqAction = E_ReqAction.INBOUND) OR (s_eReqAction = E_ReqAction.OUTBOUND) ) THEN
						s_eSequence := E_SeqCleanroomConnect.UNDOCK_TB;
					ELSE
						s_eSequence := E_SeqCleanroomConnect.READY;
					END_IF
					
				END_IF
		END_IF
		
	//PICK TROLLEY FROM TB/////////////////////////////////////////////////////////////////////////
	E_SeqCleanroomConnect.PICK_TROLLEY_FROM_TB:
		IF s_fbSeqControl.q_bStaEntry THEN
			GVL_Modules.g_emLiftingTransport.m_ReqPickTrolleyFromTB();
		END_IF
		
		IF GVL_Modules.g_emLiftingTransport.p_bStaTrollPickedFromTB
			AND GVL_Modules.g_emLiftingTransport.p_bStaReady THEN
			
			IF (s_eReqAction = E_ReqAction.INBOUND) THEN
				s_eSequence := E_SeqCleanroomConnect.OPEN_CLEANROOM_DOOR;
			ELSE
				s_bStaDockTbDone := FALSE;
				s_bStaUnDockTbDone := FALSE;
				s_bStaOpenInnerTbDoorDone := FALSE;
				s_bStaCloseInnerTbDoorDone := FALSE;
				s_bStaPickTrolleyFromTbDone := TRUE;
				s_bStaPlaceTrolleyInTbDone := FALSE;
				
				s_eSequence := E_SeqCleanroomConnect.READY;
			END_IF
		END_IF
		
	//PLACE TROLLEY IN TB//////////////////////////////////////////////////////////////////////////
	E_SeqCleanroomConnect.PLACE_TROLLEY_IN_TB:
		IF s_fbSeqControl.q_bStaEntry THEN
			GVL_Modules.g_emLiftingTransport.m_ReqPlaceTrolleyInTB();
		END_IF
		
		IF GVL_Modules.g_emLiftingTransport.p_bStaTrollPlacedInTB
			AND GVL_Modules.g_emLiftingTransport.p_bStaReady THEN
			
			IF (s_eReqAction = E_ReqAction.OUTBOUND) THEN
				s_eSequence := E_SeqCleanroomConnect.CLOSE_CLEANROOM_DOOR;
			ELSIF (s_eReqAction = E_ReqAction.PLACE_TROLLEY_IN_TB) THEN
				s_eSequence := E_SeqCleanroomConnect.READY;
			ELSE
				s_bStaDockTbDone := FALSE;
				s_bStaUnDockTbDone := FALSE;
				s_bStaOpenInnerTbDoorDone := FALSE;
				s_bStaCloseInnerTbDoorDone := FALSE;
				s_bStaPickTrolleyFromTbDone := FALSE;
				s_bStaPlaceTrolleyInTbDone := TRUE;
				
				s_eSequence := E_SeqCleanroomConnect.READY;
			END_IF
		END_IF
		
	//OPEN CLEANROOM DOOR//////////////////////////////////////////////////////////////////////////
	E_SeqCleanroomConnect.OPEN_CLEANROOM_DOOR:
		{warning '#FUMO3: Add future/FUMO3 code'}
		IF ( (s_eReqAction = E_ReqAction.INBOUND) (*OR (s_eReqAction = E_ReqAction.PICK_TROLLEY_FROM_TB)*) ) THEN
			s_eSequence := E_SeqCleanroomConnect.CLOSE_CLEANROOM_DOOR;
		ELSIF (s_eReqAction = E_ReqAction.OUTBOUND) THEN
			s_eSequence := E_SeqCleanroomConnect.PLACE_TROLLEY_IN_TB;
		END_IF
		
	//CLOSE CLEANROOM DOOR/////////////////////////////////////////////////////////////////////////
	E_SeqCleanroomConnect.CLOSE_CLEANROOM_DOOR:
		;
		{warning '#FUMO3: Add future/FUMO3 code'}
		s_eSequence := E_SeqCleanroomConnect.CLOSE_INNER_TB_DOOR;
		
	//STOP/////////////////////////////////////////////////////////////////////////////////////////
	E_SeqCleanroomConnect.STOP:
		//Do not use .qEnrty forced stop doesn't make use of fbSeqControl
		
		s_eReqAction := E_ReqAction.NONE;
		
		IF (s_eCtrlState = E_CtrlState.IDLE) THEN
			s_eSequence := E_SeqCleanroomConnect.START;
		END_IF
		
	//ERROR////////////////////////////////////////////////////////////////////////////////////////
	E_SeqCleanroomConnect.ERROR:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_eReqAction := E_ReqAction.NONE;
			
			IF s_ePreviousStep > E_SeqCleanroomConnect.START
				AND s_ePreviousStep < E_SeqCleanroomConnect.ERROR THEN
				s_eResumeStep := s_ePreviousStep;
			ELSE 
				s_eResumeStep := E_SeqCleanroomConnect.IDLE;
			END_IF
		END_IF
		
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_FullCycle" Id="{85945a60-1e58-4d91-af47-0c270dd5f580}">
      <Declaration><![CDATA[METHOD PUBLIC m_FullCycle : BOOL

VAR_INPUT
	i_objTB : REFERENCE TO OBJ_Carrier;
END_VAR

VAR_INST
	osrTbToCenter : R_TRIG;
	osrTbToDocking : R_TRIG;
	osrTbToInfeed : R_TRIG;
	osrCenterTb : R_TRIG;
	
	osrDockTb : R_TRIG;
	osrUndockTb : R_TRIG;
	osrOpenInnerDoor : R_TRIG;
	osrCloseInnerDoor : R_TRIG;
	
	osrPickTrolleyFromTb : R_TRIG;
	osrPlaceTrollerInTb : R_TRIG;
	
	arr_bTestCmd : ARRAY[0..15] OF BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT(__ISVALIDREF(i_objTB)) THEN
	RETURN;
END_IF

m_SeqCleanroomConnect();

//Pallet Conveyor
IF arr_bTestCmd[0] THEN GVL_Modules.g_emPalletConveyor.m_ReqTB_ToInfeed(); arr_bTestCmd[0] := FALSE; END_IF
IF arr_bTestCmd[1] THEN GVL_Modules.g_emPalletConveyor.m_ReqTB_ToCenter(); arr_bTestCmd[1] := FALSE; END_IF
IF arr_bTestCmd[2] THEN GVL_Modules.g_emPalletConveyor.m_ReqCenteringTB(); arr_bTestCmd[2] := FALSE; END_IF
IF arr_bTestCmd[3] THEN GVL_Modules.g_emPalletConveyor.m_ReqTB_ToDocking(); arr_bTestCmd[3] := FALSE; END_IF

//Docking Interface
IF arr_bTestCmd[4] THEN GVL_Modules.g_emDockingInterface.m_ReqDockTB(); arr_bTestCmd[4] := FALSE; END_IF
IF arr_bTestCmd[5] THEN GVL_Modules.g_emDockingInterface.m_ReqOpenInnerDoor(); arr_bTestCmd[5] := FALSE; END_IF
IF arr_bTestCmd[6] THEN GVL_Modules.g_emDockingInterface.m_ReqCloseInnerDoor(); arr_bTestCmd[6] := FALSE; END_IF
IF arr_bTestCmd[7] THEN GVL_Modules.g_emDockingInterface.m_ReqUndockTB(); arr_bTestCmd[7] := FALSE; END_IF

//Lifting transport
IF arr_bTestCmd[8] THEN GVL_Modules.g_emLiftingTransport.m_ReqGoToIdle(); arr_bTestCmd[8] := FALSE; END_IF
IF arr_bTestCmd[9] THEN GVL_Modules.g_emLiftingTransport.m_ReqPickTrolleyFromTB(); arr_bTestCmd[9] := FALSE; END_IF
IF arr_bTestCmd[10] THEN GVL_Modules.g_emLiftingTransport.m_ReqPlaceTrolleyInTB(); arr_bTestCmd[10] := FALSE; END_IF

//Unit will control lower-layer control modules based on data in Object Carrier
//By changing the data in this object the behanvior can be manipulated / controlled.

{warning '#TODO: Na gaan of het in onderstaande code niet beter zou zijn om puur te kijken naar de data uit de struct ipv naar properties uit de onderliggende modules?'}
//zoals bij voorbeeld voor TB centered status

//EM_PalletConveyor
IF i_objTB.p_eDestination <> E_Location.UNKNOWN	THEN

	//Transporting TB to Center
	osrTbToCenter(
		CLK := (sFbModeStateControl.p_eCtrlState = E_CtrlState.RUNNING)
		AND i_objTB.p_eDestination > i_objTB.p_eActLocation
		AND i_objTB.p_eActLocation < E_Location.CENTERING
		AND i_objTB.p_bOuterDoorOpened
		AND i_objTB.p_bApprovedAtInfeed);
		
	IF osrTbToCenter.Q THEN
		GVL_Modules.g_emPalletConveyor.m_ReqTB_ToCenter();
	END_IF
	
	//Transporting TB to Docking
	osrTbToDocking(
		CLK := (sFbModeStateControl.p_eCtrlState = E_CtrlState.RUNNING)
		AND i_objTB.p_eDestination > i_objTB.p_eActLocation
		AND i_objTB.p_eActLocation < E_Location.DOCKING
		AND GVL_Modules.g_emPalletConveyor.p_bStaTB_CenteringDone
		AND GVL_Modules.g_emDockingInterface.p_bStaUndocked);
		
	IF osrTbToDocking.Q THEN
		GVL_Modules.g_emPalletConveyor.m_ReqTB_ToDocking();
	END_IF
	
	//Transporting TB to Infeed
	osrTbToInfeed(
		CLK := (sFbModeStateControl.p_eCtrlState = E_CtrlState.RUNNING)
		AND i_objTB.p_eDestination < i_objTB.p_eActLocation
		AND i_objTB.p_eActLocation > E_Location.INFEED
		AND GVL_Modules.g_emDockingInterface.p_bStaUndocked);
		
	IF osrTbToInfeed.Q THEN
		GVL_Modules.g_emPalletConveyor.m_ReqTB_ToInfeed();
	END_IF
	
	//Centering TB
	osrCenterTb(
		CLK := (sFbModeStateControl.p_eCtrlState = E_CtrlState.RUNNING)
		AND i_objTB.p_eActLocation = E_Location.CENTERING
		AND NOT(GVL_Modules.g_emPalletConveyor.p_bStaTB_CenteringDone));
		
	IF osrCenterTb.Q THEN
		GVL_Modules.g_emPalletConveyor.m_ReqCenteringTB();
	END_IF
	
END_IF
	
//EM_DockingInterface
IF i_objTB.p_eDestination <> E_Location.UNKNOWN	THEN
	
	//Docking TB
	osrDockTb(
		CLK := (sFbModeStateControl.p_eCtrlState = E_CtrlState.RUNNING)
		AND i_objTB.p_eActLocation = E_Location.DOCKING
		AND i_objTB.p_eDestination > E_Location.DOCKING
		AND NOT(GVL_Modules.g_emDockingInterface.p_bStaDocked));
	
	IF osrDockTb.Q THEN
		GVL_Modules.g_emDockingInterface.m_ReqDockTB();
	END_IF
	
	//Undocking TB
	osrUndockTb(
		CLK := (sFbModeStateControl.p_eCtrlState = E_CtrlState.RUNNING)
		AND i_objTB.p_eActLocation = E_Location.DOCKING //Is this about the TB or Trolley location?
		AND i_objTB.p_eDestination < E_Location.DOCKING
		AND GVL_Modules.g_emDockingInterface.p_bStaInnerDoorClosed
		AND NOT(GVL_Modules.g_emDockingInterface.p_bStaUndocked));
		
	IF osrUndockTb.Q THEN
		GVL_Modules.g_emDockingInterface.m_ReqUndockTB();
	END_IF

	//Opening Inner Door TB
	osrOpenInnerDoor(
		CLK := (sFbModeStateControl.p_eCtrlState = E_CtrlState.RUNNING)
		AND i_objTB.p_eActLocation = E_Location.DOCKING
		AND i_objTB.p_eDestination > E_Location.DOCKING
		AND GVL_Modules.g_emDockingInterface.p_bStaDocked
		AND NOT(GVL_Modules.g_emDockingInterface.p_bStaInnerDoorOpened));
		
	IF osrOpenInnerDoor.Q THEN
		GVL_Modules.g_emDockingInterface.m_ReqOpenInnerDoor();
	END_IF
	
	//Closing Inner Door TB
	osrCloseInnerDoor(
		CLK := (sFbModeStateControl.p_eCtrlState = E_CtrlState.RUNNING)
		AND i_objTB.p_eActLocation = E_Location.DOCKING
		AND i_objTB.p_eDestination < E_Location.DOCKING
		AND NOT(GVL_Modules.g_emDockingInterface.p_bStaInnerDoorClosed));
		
	IF osrCloseInnerDoor.Q THEN
		GVL_Modules.g_emDockingInterface.m_ReqCloseInnerDoor();
	END_IF
	
END_IF

//EM_LiftingTransport
IF i_objTB.p_eDestination <> E_Location.UNKNOWN	THEN

	//Picking trolley from TB
	osrPickTrolleyFromTb(
		CLK := (sFbModeStateControl.p_eCtrlState = E_CtrlState.RUNNING)
		AND i_objTB.p_eDestination > i_objTB.p_eActLocation
		AND i_objTB.p_eActLocation < E_Location.CENTERING
		AND i_objTB.p_bOuterDoorOpened
		AND i_objTB.p_bApprovedAtInfeed);
		
	IF osrPickTrolleyFromTb.Q THEN
		GVL_Modules.g_emLiftingTransport.m_ReqPickTrolleyFromTB();
	END_IF
	
	//Place trolley TB TB
	osrPickTrolleyFromTb(
		CLK := (sFbModeStateControl.p_eCtrlState = E_CtrlState.RUNNING)
		AND i_objTB.p_eDestination > i_objTB.p_eActLocation
		AND i_objTB.p_eActLocation < E_Location.CENTERING 
		AND i_objTB.p_bOuterDoorOpened
		AND i_objTB.p_bApprovedAtInfeed);
		
	IF osrPickTrolleyFromTb.Q THEN
		GVL_Modules.g_emLiftingTransport.m_ReqPickTrolleyFromTB();
	END_IF
	
END_IF

(* Lod Code 20241108
//EM_PalletConveyor
	
	//Transporting TB to Center
	IF i_objTB.p_eDestination <> E_Location.UNKNOWN
		AND i_objTB.p_eDestination > i_objTB.p_eActLocation
		AND i_objTB.p_eActLocation < E_Location.CENTERING
		AND i_objTB.p_bOuterDoorOpened
		AND i_objTB.p_bApprovedAtInfeed THEN
			GVL_Modules.g_emPalletConveyor.m_ReqTB_ToCenter();
			
	//Transporting TB to Docking
	ELSIF i_objTB.p_eDestination <> E_Location.UNKNOWN
		AND i_objTB.p_eDestination > i_objTB.p_eActLocation
		AND i_objTB.p_eActLocation < E_Location.DOCKING
		AND GVL_Modules.g_emPalletConveyor.p_bStaTB_CenteringDone
		AND GVL_Modules.g_emDockingInterface.p_bStaUndocked THEN
			GVL_Modules.g_emPalletConveyor.m_ReqTB_ToDocking();
		
	//Transporting TB to Infeed
	ELSIF i_objTB.p_eDestination <> E_Location.UNKNOWN
		AND i_objTB.p_eDestination < i_objTB.p_eActLocation
		AND i_objTB.p_eActLocation > E_Location.INFEED
		AND GVL_Modules.g_emDockingInterface.p_bStaUndocked THEN
			GVL_Modules.g_emPalletConveyor.m_ReqTB_ToInfeed();
		
	END_IF
	
	//Centering TB
	IF i_objTB.p_eDestination <> E_Location.UNKNOWN
		AND i_objTB.p_eActLocation = E_Location.CENTERING
		AND NOT(GVL_Modules.g_emPalletConveyor.p_bStaTB_CenteringDone) THEN
		//AND NOT(i_objTB.p_bCenteringDone) AND NOT(bTest) THEN
		;
		//GVL_Modules.g_emPalletConveyor.m_ReqCenteringTB();
	END_IF
	
	osrCenterTb(
		CLK := i_objTB.p_eDestination <> E_Location.UNKNOWN
		AND i_objTB.p_eActLocation = E_Location.CENTERING
		AND NOT(GVL_Modules.g_emPalletConveyor.p_bStaTB_CenteringDone));
		
	IF osrCenterTb.Q THEN
		GVL_Modules.g_emPalletConveyor.m_ReqCenteringTB();
	END_IF
	
//EM_DockingInterface

	//Docking TB
	IF i_objTB.p_eDestination <> E_Location.UNKNOWN
		AND i_objTB.p_eActLocation = E_Location.DOCKING
		AND i_objTB.p_eDestination > E_Location.DOCKING
		AND NOT(GVL_Modules.g_emDockingInterface.p_bStaDocked) THEN
			GVL_Modules.g_emDockingInterface.m_ReqDockTB();
			
	//Undocking TB
	ELSIF i_objTB.p_eDestination <> E_Location.UNKNOWN
		AND i_objTB.p_eActLocation = E_Location.DOCKING		//Is this about the TB or Trolley location?
		AND i_objTB.p_eDestination < E_Location.DOCKING
		AND GVL_Modules.g_emDockingInterface.p_bStaInnerDoorClosedAndLocked
		AND NOT(GVL_Modules.g_emDockingInterface.p_bStaUndocked) THEN 
			GVL_Modules.g_emDockingInterface.m_ReqUndockTB();
		
	//Opening Inner Door TB
	ELSIF i_objTB.p_eDestination <> E_Location.UNKNOWN
		AND i_objTB.p_eActLocation = E_Location.DOCKING
		AND i_objTB.p_eDestination > E_Location.DOCKING
		AND GVL_Modules.g_emDockingInterface.p_bStaDocked
		AND NOT(GVL_Modules.g_emDockingInterface.p_bStaInnerDoorOpenedAndReleased) THEN
			GVL_Modules.g_emDockingInterface.m_ReqOpenInnerDoor();
			
	//Closing Inner Door TB
	ELSIF i_objTB.p_eDestination <> E_Location.UNKNOWN
		AND i_objTB.p_eActLocation = E_Location.DOCKING
		AND i_objTB.p_eDestination < E_Location.DOCKING
		AND NOT(GVL_Modules.g_emDockingInterface.p_bStaInnerDoorClosedAndLocked) THEN
			GVL_Modules.g_emDockingInterface.m_ReqCloseInnerDoor();
			
	END_IF
*)
//EM_LiftingTransport
	//Get Trolley from TB to Cabin
	//Get Trolley from Cabin to TB
	//..
	
//EM_Doors
	//Open Cabin door Infeed
	//Close Cabin door Infeed
	
	//Release Cleanroom Door
	//Lock Cleanroom Door
	//..

//EM_..
	
	
//-- Old Code
//FullCycle
//++	m_Inbound();
//	Wait(T#5S)
//	m_Outbound();]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_Main" Id="{bf5d9d9d-3881-4722-ad23-ed0781ff35d5}">
      <Declaration><![CDATA[METHOD PUBLIC m_Main : BOOL
VAR
	s_bStaReady : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT SUPER^.m_Main() THEN
	RETURN;
END_IF

GVL.g_osrNotify();
GVL.g_osrNotify.CLK := FALSE;

m_Main := TRUE;

CASE s_eCtrlMode OF
	E_CtrlMode.IDLE:
		s_eReqAction := E_ReqAction.NONE;
		
	E_CtrlMode.AUTOMATIC:
		//Wait for commands from Hmi
		IF s_fbHmiBtnInbound.p_osrBtnPress THEN
			s_eReqAction := E_ReqAction.INBOUND;
		END_IF
		
		IF s_fbHmiBtnOutbound.p_osrBtnPress THEN
			s_eReqAction := E_ReqAction.OUTBOUND;
		END_IF
		
		IF s_fbHmiBtnDockTB.p_osrBtnPress THEN
			s_eReqAction := E_ReqAction.DOCK_TB;
		END_IF
		
		IF s_fbHmiBtnUndockTB.p_osrBtnPress THEN
			s_eReqAction := E_ReqAction.UNDOCK_TB;
		END_IF
		
		IF s_fbHmiBtnOpenInnerTBDoor.p_osrBtnPress THEN
			s_eReqAction := E_ReqAction.OPEN_INNER_TB_DOOR;
		END_IF
		
		IF s_fbHmiBtnCloseInnerTBDoor.p_osrBtnPress THEN
			s_eReqAction := E_ReqAction.CLOSE_INNER_TB_DOOR;
		END_IF
		
		IF s_fbHmiBtnPickTrolleyFromTB.p_osrBtnPress THEN
			s_eReqAction := E_ReqAction.PICK_TROLLEY_FROM_TB;
		END_IF
		
		IF s_fbHmiBtnPlaceTrolleyInTB.p_osrBtnPress THEN
			s_eReqAction := E_ReqAction.PLACE_TROLLEY_IN_TB;
		END_IF
		
		_m_Sequence();
		
	E_CtrlMode.MANUAL:
		;
		
	E_CtrlMode.MAINTENANCE:
		;
		
	E_CtrlMode.IO:
		;
		
	E_CtrlMode.CLEANING:
		;
		
END_CASE

IF s_eCtrlMode <> E_CtrlMode.AUTOMATIC THEN
	s_eReqAction := E_ReqAction.NONE;
END_IF

s_bStaReady := (s_eSequence = E_SeqCleanroomConnect.READY);

s_fbHmiBtnDockTB.p_bStaEnabled := s_bStaReady AND NOT(GVL_Modules.g_emDockingInterface.p_bStaDocked);
s_fbHmiBtnUndockTB.p_bStaEnabled := s_bStaReady AND NOT(GVL_Modules.g_emDockingInterface.p_bStaUnDocked) AND (GVL_Modules.g_emDockingInterface.p_bStaInnerDoorClosed);
s_fbHmiBtnOpenInnerTBDoor.p_bStaEnabled := s_bStaReady AND NOT(GVL_Modules.g_emDockingInterface.p_bStaInnerDoorOpened) AND (GVL_Modules.g_emDockingInterface.p_bStaDocked);
s_fbHmiBtnCloseInnerTBDoor.p_bStaEnabled := s_bStaReady AND NOT(GVL_Modules.g_emDockingInterface.p_bStaInnerDoorClosed);
s_fbHmiBtnPickTrolleyFromTB.p_bStaEnabled := s_bStaReady AND GVL_Modules.g_emDockingInterface.p_bStaInnerDoorOpened;
s_fbHmiBtnPlaceTrolleyInTB.p_bStaEnabled := s_bStaReady AND GVL_Modules.g_emDockingInterface.p_bStaInnerDoorOpened;

//IO-mode//////////////////////////////////////////////////////////////////////////////////////////
IF (s_eCtrlMode = E_CtrlMode.IO) AND (s_eCtrlState = E_CtrlState.RUNNING) THEN
	s_bHmiForceOutputEnabled := TRUE;
	s_bHmiForceOutputRGBEnabled := NOT(s_cmCabinStateIndicator.p_bStaColorWhite);
	s_bHmiForceOutputWEnabled := NOT(s_cmCabinStateIndicator.p_bStaColorRed OR s_cmCabinStateIndicator.p_bStaColorGreen OR s_cmCabinStateIndicator.p_bStaColorBlue);
ELSE
	s_bHmiForceOutputEnabled := FALSE;
	s_bHmiForceOutputRGBEnabled := FALSE;
	s_bHmiForceOutputWEnabled := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>