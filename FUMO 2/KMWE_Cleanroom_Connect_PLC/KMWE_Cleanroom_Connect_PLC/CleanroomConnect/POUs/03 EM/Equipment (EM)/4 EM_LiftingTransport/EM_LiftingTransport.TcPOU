<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="EM_LiftingTransport" Id="{82ac1e56-2937-4df1-886d-5bc6dc15361f}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK EM_LiftingTransport EXTENDS EM_Base IMPLEMENTS I_EM_LiftingTransport

VAR CONSTANT
	c_fHEIGHT_OFFSET : LREAL := 99.874922; //[mm] this value is derived from the (Calculation and Information.xlsx)
	c_fSPINDLE_OFFSET : LREAL := 0.0; //[mm] this value can be changed based on the real machine
	c_fLEG_LENGTH : LREAL := 1000.0; //[mm] derived from the 3D-model
	
	c_fMIN_LIFT_TARGET : LREAL := 0.0; //[mm] (**USED IN HMI**)
	c_fMAX_LIFT_TARGET : LREAL := 410.0; //[mm] (**USED IN HMI**)
	
	c_fMIN_TRANSPORT_TARGET : LREAL := 0.0; //[mm] (**USED IN HMI**)
	c_fMAX_TRANSPORT_TARGET : LREAL := 1720.0; //[mm] (**USED IN HMI**)
	
	c_fMIN_LIFT_HEIGHT_TO_EXTRACT_TRANSPORT : LREAL := 305.0; //[mm]
	c_fMAX_LIFT_HEIGHT_TO_EXTRACT_TRANSPORT : LREAL := 405.0; //[mm]
	
	c_fMIN_TRANSPORT_POSITION_TO_LOWER_LIFT : LREAL := -1.0; //[mm]
	c_fMAX_TRANSPORT_POSITION_TO_LOWER_LIFT : LREAL := 1.0; //[mm]
	
	c_fMIN_LIFT_POSITION_TO_CHECK_INTERLOCK : LREAL := 300.0; //[mm]
	c_fMAX_LIFT_POSITION_TO_CHECK_TROLLEY : LREAL := 10.0; //[mm]
	
	c_fEND_TRANSPORT_POSITION_COLLISION_CHECK : LREAL := 50.0; //[mm]
END_VAR

VAR_INPUT
//Inputs
	i_ref_stSettings : REFERENCE TO ST_SettingsLiftingTransport;
	
	// External interlocks (from outside this EM)
	{warning '#TODO: Delete unused (not written extrnal) inputs'}
	i_stExtIlckLiftUp : ST_Interlock;			//-- NOT_USED
	i_stExtIlckLiftDown : ST_Interlock;			//-- NOT_USED
	i_stExtIlckTransportExtract : ST_Interlock;
	i_stExtIlckTransportRetract : ST_Interlock;	//-- NOT_USED
	
	i_eCtrlState : E_CtrlState;
	
	I_nInfoDataInputLevel AT %I* : UINT;	//Bit8: STO Input Level (UINT8)
END_VAR

VAR_OUTPUT
	q_bStaWarning : BOOL;
	Q_bDriveStateSTO AT %Q* : BOOL;
END_VAR

VAR
	//Interlocks
	s_fbIlckHandlerLiftUp : FB_InterlockHandler;
	s_fbIlckHandlerLiftDown : FB_InterlockHandler;
	
	s_fbIlckHandlerTransportExtract : FB_InterlockHandler;
	s_fbIlckHandlerTransportRetract : FB_InterlockHandler;
	
//------------------------------------------//
	//Control Modules
	axisLift : AXIS_REF; //??AXIS_REF; TC2_MC2.AXIS_REF;
	s_cmLift : CM_Servo; // Including 2 limit switched and 1 reference switch
	
	axisTransport : AXIS_REF; //??AXIS_REF TC2_MC2.AXIS_REF;
	s_cmTransport : CM_Servo; // Including 2 limit switched and 1 reference switch
	
//------------------------------------------//

//------------------------------------------//
//Inputs
	s_diStaTrolleyOnPositionLeft : FB_DigInput;
	s_diStaTrolleyOnPositionRight : FB_DigInput;
	s_diStaCabinAreaOccupied : FB_DigInput;
	
	s_diStaCollisionAvoidanceSensor : FB_DigInput;
	s_diStaTrolleyLocked : FB_DigInput;
//------------------------------------------//

//------------------------------------------//
//Outputs

//------------------------------------------//
	
	//Requests
	s_bReqGoToIdle : BOOL := FALSE;
	s_bReqPickTrolleyFromTB : BOOL := FALSE;
	s_bReqPlaceTrolleyInTB : BOOL := FALSE;
	
	//States
	s_bStaLiftDriveError : BOOL := FALSE;
	s_bStaTransportDriveError : BOOL := FALSE;
	
	s_bStaTrolleyOnPositionLeft : BOOL := FALSE;
	s_bStaTrolleyOnPositionRight : BOOL := FALSE;
	s_bStaCabinAreaOccupied : BOOL := FALSE;
	
	s_bStaCabinAreaFree : BOOL := FALSE;
	s_bStaTrolleyAtLiftPos : BOOL := FALSE;
	
	s_bStaCollisionAvoidanceSensor : BOOL := FALSE;
	s_bStaTrolleyLocked : BOOL := FALSE;
	
	s_fSetLiftPosition : LREAL; //[mm]
	s_fActLiftPosition : LREAL; //Converted to vertical movement of scissor lift [mm]
	
	s_fSetTransportPosition : LREAL; //[mm]
	s_fActTransportPosition : LREAL; //Converted to horizontal movement of transport unit [mm]
	
	//Properties
	s_bStaAtIdlePosition : BOOL := FALSE;
	s_bStaTrolleyPickedFromTB : BOOL := FALSE;
	s_bStaTrolleyPlacedInTB : BOOL := FALSE;
	s_bStaTrolleyOnSystem : BOOL := FALSE;
	
	//Interlockes
	s_bIlckLiftUp : BOOL := TRUE;
	s_bIlckLiftDown : BOOL := TRUE;
	s_bIlckTransportExtract : BOOL := TRUE;
	s_bIlckTransportRetract : BOOL := TRUE;
	
	//Alarms
	s_sReason : STRING;
	
	s_fbAlarmHandlerLiftDrive : FB_AlarmHandler;
	s_fbAlarmHandlerTransportDrive : FB_AlarmHandler;
	s_fbAlarmHandlerLockTrolleyFailed : FB_AlarmHandler;
	s_fbAlarmHandlerUnlockTRolleyFailed : FB_AlarmHandler;
	s_fbAlarmHandlerNoTrolleyPlaced : FB_AlarmHandler;
	s_fbAlarmHandlerCabinNotEmpty : FB_AlarmHandler;
	s_fbAlarmHandlerCmdNotAllowed : FB_AlarmHandler;
	
	s_bErrLiftDrive : BOOL;
	s_bErrTransportDrive : BOOL;
	s_bErrLockTrolleyFailed : BOOL;
	s_bErrUnlockTRolleyFailed : BOOL;
	s_bErrNoTrolleyPlaced : BOOL;
	s_bErrCabinNotEmpty : BOOL;
	s_bErrCmdNotAllowed : BOOL;
	
	//Warnings
	s_fbAlarmHandlerSafetyDoorNotClosed : FB_AlarmHandler;
	s_bWrnSafetyDoorNotClosed : BOOL;
	
	s_bStaWarning : BOOL;
	
	s_sMessage : STRING(128);
	
	//Sequencers
	s_eSequence : E_SeqLiftingTransport;
	s_fbSeqControl : FB_SeqControl;
	
	s_bActionDone : BOOL := FALSE;
	s_bNextStep : BOOL := FALSE;
	
	s_ePreviousStep : E_SeqLiftingTransport;
	s_eResumeStep : E_SeqLiftingTransport;
	s_sResumeStep : STRING;
	
	//Hmi
	//Buttons
	s_fbHmiBtnGoToIdle : FB_HmiBtn;
	s_fbHmiBtnPickTrolleyFromTB : FB_HmiBtn;
	s_fbHmiBtnPlaceTrolleyInTB : FB_HmiBtn;
	
	//Leds
	s_fbHmiLedTrolleyOnPositionLeft : FB_HmiLed;
	s_fbHmiLedTrolleyOnPositionRight : FB_HmiLed;
	s_fbHmiLedCabinAreaOccupied	: FB_HmiLed;
	s_fbHmiLedCollisionAvoidanceSensor : FB_HmiLed;
	s_fbHmiLedTrolleyLocked : FB_HmiLed;
	s_fbHmiLedTrolleyUnlocked : FB_HmiLed;
	
	s_fbHmiLedAtIdlePosition : FB_HmiLed;
	s_fbHmiLedTrolleyPickedFromTB : FB_HmiLed;
	s_fbHmiLedTrolleyPlacedInTB : FB_HmiLed;
	
	{warning '#TODO: Het zou beter zijn om dit onder te brengen in de onderstaande control modules'}
	s_bHmiForceOutputEnabled : BOOL;
	
END_VAR

VAR PERSISTENT //Variables below will be returned during: Power Cycle, Active Configuration, Download, Cold Restart
	s_eLastStepPersistent : E_SeqLiftingTransport := E_SeqLiftingTransport.READY;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
SUPER^();
]]></ST>
    </Implementation>
    <Folder Name="Base" Id="{aa880d32-2da2-45ff-bcea-b6be34b0a44b}" />
    <Method Name="_m_Alarms" Id="{77ac2c1c-b354-4acb-9f0d-e0fd9e0a3a94}" FolderPath="Base\">
      <Declaration><![CDATA[METHOD PROTECTED _m_Alarms : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT SUPER^._m_Alarms() THEN
	RETURN;
END_IF

//Set alarm bits
s_bErrLiftDrive S= s_cmLift.p_bError;
s_bErrTransportDrive S= s_cmTransport.p_bError;

// Alarm Handlers
s_fbAlarmHandlerLiftDrive(
	i_bStaActive := s_bErrLiftDrive,
	i_sAlarmText := CONCAT(i_sEmName, CONCAT( ': Scissor Lift Drive error: ', s_sReason)) );
	
s_fbAlarmHandlerTransportDrive(
	i_bStaActive := s_bErrTransportDrive,
	i_sAlarmText := CONCAT(i_sEmName, CONCAT( ': Transport Unit Drive error: ', s_sReason)) );
	
s_fbAlarmHandlerLockTrolleyFailed(
	i_bStaActive := s_bErrLockTrolleyFailed,
	i_sAlarmText := CONCAT(i_sEmName, ': Locking Trolley Failed.') );
	
s_fbAlarmHandlerUnlockTrolleyFailed(
	i_bStaActive := s_bErrUnlockTrolleyFailed,
	i_sAlarmText := CONCAT(i_sEmName, ': Unlocking Trolley Failed.') );
	
s_fbAlarmHandlerNoTrolleyPlaced(
	i_bStaActive := s_bErrNoTrolleyPlaced,
	i_sAlarmText := CONCAT(i_sEmName, ': No Trolley Placed In Cabin.') );
	
s_fbAlarmHandlerCabinNotEmpty(
	i_bStaActive := s_bErrCabinNotEmpty,
	i_sAlarmText := CONCAT(i_sEmName, ': Cabin Not Empty.') );
	
s_fbAlarmHandlerCmdNotAllowed(
	i_bStaActive := s_bErrCmdNotAllowed,
	i_sAlarmText := CONCAT(i_sEmName, CONCAT(': ', s_sMessage)) );
	
// Reset warnings
IF i_bCmdReset THEN
	s_bWrnSafetyDoorNotClosed := FALSE;
	s_bErrLockTrolleyFailed := FALSE;
	s_bErrUnlockTrolleyFailed := FALSE;
	s_bErrNoTrolleyPlaced := FALSE;
	s_bErrCabinNotEmpty := FALSE;
	s_bErrCmdNotAllowed := FALSE;
END_IF

s_bStaError :=
	s_cmLift.p_bError
	OR s_cmTransport.p_bError
	OR s_fbAlarmHandlerLockTrolleyFailed.q_bStaActive
	OR s_fbAlarmHandlerUnlockTRolleyFailed.q_bStaActive
	OR s_fbAlarmHandlerNoTrolleyPlaced.q_bStaActive
	OR s_fbAlarmHandlerCabinNotEmpty.q_bStaActive
	OR s_fbAlarmHandlerCmdNotAllowed.q_bStaActive;
	
s_bStaWarning :=
	s_fbAlarmHandlerSafetyDoorNotClosed.q_bStaActive
	OR s_cmLift.p_bWarning
	OR s_cmTransport.p_bWarning;
	
_m_Alarms := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_AutomaticControl" Id="{51dbf1d4-9c3c-42ad-87fe-cdadd1984100}">
      <Declaration><![CDATA[METHOD PROTECTED _m_AutomaticControl : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
_m_Sequence();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_CmdGoToIdle" Id="{5f07294c-c083-4786-a1a2-586c95e439f7}">
      <Declaration><![CDATA[METHOD PROTECTED _m_CmdGoToIdle : BOOL
VAR_INPUT
	i_refReason : REFERENCE TO STRING(128);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT i_bReqEnable THEN
	RETURN;
END_IF

_m_CmdGoToIdle := FALSE;
s_bErrCmdNotAllowed := TRUE;

IF s_bIlckLiftDown THEN
	i_refReason := CONCAT('Cmd Go To Idle: Lift Interlocked - ', s_fbIlckHandlerLiftDown.p_sReason);
//--ELSIF s_bIlckLiftUp THEN
//--	i_refReason := CONCAT('Cmd Go To Idle: Lift Interlocked - ', fbIlckHandlerLiftUp.p_sReason);
ELSIF s_bIlckTransportRetract THEN
	i_refReason := CONCAT('Cmd Go To Idle: Transpoort Interlocked - ', s_fbIlckHandlerTransportRetract.p_sReason);
//--ELSIF s_bIlckTransportExtract THEN
//--	i_refReason := CONCAT('Cmd Go To Idle: Transport Interlocked - ', fbIlckHandlerTransportExtract.p_sReason);
ELSE
	i_refReason := '-';
	_m_CmdGoToIdle := TRUE;	
	s_bErrCmdNotAllowed := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_CmdPickTrolleyFromTB" Id="{3a534c15-c636-468b-8b82-6fd59e761d1a}">
      <Declaration><![CDATA[METHOD PROTECTED _m_CmdPickTrolleyFromTB : BOOL
VAR_INPUT
	i_refReason : REFERENCE TO STRING(128);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT i_bReqEnable THEN
	RETURN;
END_IF

_m_CmdPickTrolleyFromTB := FALSE;
s_bErrCmdNotAllowed := TRUE;

IF NOT(s_bStaCabinAreaFree) THEN
	i_refReason := 'Cmd Pick Trolley From TB: Interlocked - Cabin Position Not Free';
ELSIF NOT(s_bStaCollisionAvoidanceSensor) THEN
	i_refReason := 'Cmd Pick Trolley From TB: Interlocked - No Trolley Detected In TB';
ELSIF s_bIlckLiftDown THEN
	i_refReason := CONCAT('Cmd Pick Trolley From TB: Lift Interlocked - ', s_fbIlckHandlerLiftDown.p_sReason);
ELSIF s_bIlckLiftUp THEN
	i_refReason := CONCAT('Cmd Pick Trolley From TB: Lift Interlocked - ', s_fbIlckHandlerLiftUp.p_sReason);
ELSIF s_bIlckTransportRetract THEN
	i_refReason := CONCAT('Cmd Pick Trolley From TB: Transpoort Interlocked - ', s_fbIlckHandlerTransportRetract.p_sReason);
ELSIF s_bIlckTransportExtract THEN
	i_refReason := CONCAT('Cmd Pick Trolley From TB: Transport Interlocked - ', s_fbIlckHandlerTransportExtract.p_sReason);
ELSE
	i_refReason := '-';
	_m_CmdPickTrolleyFromTB := TRUE;
	s_bErrCmdNotAllowed := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_CmdPlaceTrolleyInTB" Id="{fddfe49e-6281-47a3-8534-8abf984608e2}">
      <Declaration><![CDATA[METHOD PROTECTED _m_CmdPlaceTrolleyInTB : BOOL
VAR_INPUT
	i_refReason : REFERENCE TO STRING(128);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT i_bReqEnable THEN
	RETURN;
END_IF

_m_CmdPlaceTrolleyInTB := FALSE;
s_bErrCmdNotAllowed := TRUE;

IF NOT(s_bStaTrolleyAtLiftPos) THEN
	i_refReason := 'Cmd Place Trolley In TB: Interlocked - Trolley Not Place (correctly) At Cabin';
ELSIF s_bStaCollisionAvoidanceSensor THEN
	i_refReason := 'Cmd Place Trolley In TB: Interlocked - TB Not Free, or Entrance Blocked';
ELSIF s_bIlckLiftDown THEN
	i_refReason := CONCAT('Cmd Place Trolley In TB: Lift Interlocked - ', s_fbIlckHandlerLiftDown.p_sReason);
ELSIF s_bIlckLiftUp THEN
	i_refReason := CONCAT('Cmd Place Trolley In TB: Lift Interlocked - ', s_fbIlckHandlerLiftUp.p_sReason);
//--ELSIF s_bIlckTransportRetract THEN
//--	i_refReason := CONCAT('Cmd Place Trolley In TB: Transpoort Interlocked - ', fbIlckHandlerTransportRetract.p_sReason);
//--ELSIF s_bIlckTransportExtract THEN
//--	i_refReason := CONCAT('Cmd Place Trolley In TB: Transport Interlocked - ', fbIlckHandlerTransportExtract.p_sReason);
ELSE
	i_refReason := '-';
	_m_CmdPlaceTrolleyInTB := TRUE;
	s_bErrCmdNotAllowed := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_ConvLiftHeightToSpindPos" Id="{8617e5f7-c58b-4537-8cd1-e74ba22bdca2}">
      <Declaration><![CDATA[///Convert Lift Height To Spindle Position
METHOD PROTECTED _m_ConvLiftHeightToSpindPos : LREAL
VAR_INPUT
	i_fSetLiftHeight : LREAL; //[mm]
	
END_VAR
VAR
	s_fScissorHeight : LREAL;
	s_fScissorBase : LREAL; //[mm]
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Calculate spindle position as function of lift height setpoint
// a^2 + b^2 = c^2
// 	a = s_fScissorHeight
// 	b = s_fScissorBase
// 	c = c_fLEG_LENGTH

//Calculate Lift Target
//	b = SQRT( c^2 - a^2 )
s_fScissorHeight := i_fSetLiftHeight + c_fHEIGHT_OFFSET;
s_fScissorBase := SQRT(EXPT(c_fLEG_LENGTH, 2) - EXPT(s_fScissorHeight, 2));
_m_ConvLiftHeightToSpindPos := c_fLEG_LENGTH - (s_fScissorBase - c_fSPINDLE_OFFSET);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_ConvLiftToMotorPos" Id="{3e5c7f8b-1cdb-4f91-8994-492b3f27a304}">
      <Declaration><![CDATA[///Convert Lift (desired) To Motor Position
METHOD PROTECTED _m_ConvLiftToMotorPos : ST_PositioningProfile
VAR_INPUT
	i_stPosProf : ST_PositioningProfile;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Calculate required motor position as function of desired lift position

_m_ConvLiftToMotorPos := i_stPosProf;
_m_ConvLiftToMotorPos.fPos := _m_ConvLiftHeightToSpindPos(i_stPosProf.fPos);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_ConvSpindPosToLiftHeight" Id="{b4c945b7-7c49-44aa-94eb-77b098eae95c}">
      <Declaration><![CDATA[///Convert Spindle Position To Lift Height
METHOD PROTECTED _m_ConvSpindPosToLiftHeight : LREAL
VAR_INPUT
	i_fActSpindPos : LREAL; //[mm]
END_VAR
VAR
	s_fScissorHeight : LREAL;
	s_fScissorBase : LREAL; //[mm]
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Calculate lift height as function of spindle position
// a^2 + b^2 = c^2
// 	a = s_fScissorHeight
// 	b = s_fScissorBase
// 	c = c_fLEG_LENGTH

//Calculate Lift Target
//	b = SQRT( c^2 - a^2 )
s_fScissorBase := c_fLEG_LENGTH - (i_fActSpindPos - c_fSPINDLE_OFFSET);

IF (c_fLEG_LENGTH >= s_fScissorBase) THEN
	s_fScissorHeight := SQRT(EXPT(c_fLEG_LENGTH, 2) - EXPT(s_fScissorBase, 2));
ELSE
	s_fScissorHeight := c_fHEIGHT_OFFSET;
END_IF

_m_ConvSpindPosToLiftHeight := s_fScissorHeight - c_fHEIGHT_OFFSET;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_ConvTranspToMotorPos" Id="{5ab8735e-3225-492d-860a-94723f1f74f0}">
      <Declaration><![CDATA[///Convert Transport (desired) To Motor Position
METHOD PROTECTED _m_ConvTranspToMotorPos : ST_PositioningProfile
VAR_INPUT
	i_stPosProf : ST_PositioningProfile;
END_VAR
VAR
	s_fConvFactor : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// Calculate required motor position as function of desired transport unit position
s_fConvFactor := 0.5;

_m_ConvTranspToMotorPos.fPos := i_stPosProf.fPos * s_fConvFactor;
_m_ConvTranspToMotorPos.fVel := i_stPosProf.fVel * s_fConvFactor;
_m_ConvTranspToMotorPos.fAcc := i_stPosProf.fAcc * s_fConvFactor;
_m_ConvTranspToMotorPos.fDec := i_stPosProf.fDec * s_fConvFactor;
_m_ConvTranspToMotorPos.fJrk := i_stPosProf.fJrk * s_fConvFactor;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Devices" Id="{b95b1090-f72e-49a8-b75a-87fbc22bb2f7}" FolderPath="Base\">
      <Declaration><![CDATA[METHOD PROTECTED _m_Devices : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT SUPER^._m_Devices() THEN
	RETURN;
END_IF

{warning '#TODO: Not clear if this is the right way to correct the lift speed'}
//??s_cmLift.p_fSetOverride := (s_cmLift.p_fPosition / s_fActLiftPosition) * 100;

//Control module
s_cmLift(
	i_bReqEnable := i_bReqEnable,
	i_eCtrlMode := i_eCtrlMode,
	i_ref_eCtrlState := i_eCtrlState,
	i_ref_setting := i_ref_stSettings.stSettingsServoLift,
	i_bCmdReset := i_bCmdReset,
	i_refAxis := axisLift,
	i_bIclkPos := s_bIlckLiftUp,
	i_bIclkNeg := s_bIlckLiftDown);
	
s_bStaLiftDriveError := s_cmLift.p_bError;

s_cmTransport(
	i_bReqEnable := i_bReqEnable,
	i_eCtrlMode := i_eCtrlMode,
	i_ref_eCtrlState := i_eCtrlState,
	i_ref_setting := i_ref_stSettings.stSettingsServoTransport,
	i_bCmdReset := i_bCmdReset,
	i_refAxis := axisTransport,
	i_bIclkPos := s_bIlckTransportExtract,
	i_bIclkNeg := s_bIlckTransportRetract);
	
s_bStaTransportDriveError := s_cmTransport.p_bError;

s_diStaTrolleyOnPositionLeft();
s_diStaTrolleyOnPositionRight();
s_diStaCabinAreaOccupied();
s_diStaCollisionAvoidanceSensor();
s_diStaTrolleyLocked();

s_bStaTrolleyOnPositionLeft := s_diStaTrolleyOnPositionLeft.p_bStaInputDelayed;
s_bStaTrolleyOnPositionRight := s_diStaTrolleyOnPositionRight.p_bStaInputDelayed;
s_bStaCabinAreaOccupied := s_diStaCabinAreaOccupied.p_bStaInputDelayed;

s_bStaCabinAreaFree :=
	NOT(s_diStaCabinAreaOccupied.p_bStaInputDelayed
	OR s_diStaTrolleyOnPositionLeft.p_bStaInputDelayed
	OR s_diStaTrolleyOnPositionRight.p_bStaInputDelayed);
	
s_bStaTrolleyAtLiftPos :=
	s_diStaCabinAreaOccupied.p_bStaInputDelayed
	AND s_diStaTrolleyOnPositionLeft.p_bStaInputDelayed
	AND s_diStaTrolleyOnPositionRight.p_bStaInputDelayed;
	
s_bStaCollisionAvoidanceSensor := s_diStaCollisionAvoidanceSensor.p_bStaInputDelayed;
s_bStaTrolleyLocked := s_diStaTrolleyLocked.p_bStaInputDelayed;

//Statusses written to TRUE by sequencer
s_bStaAtIdlePosition := F_InRange(i_ref_stSettings.arr_stLiftPositioningProfile[0].fPos, s_fActLiftPosition, 0.5)
						AND	F_InRange(i_ref_stSettings.arr_stTransportPositioningProfile[0].fPos, s_fActTransportPosition, 0.5);

_m_Devices := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Hmi" Id="{86cd5a15-a053-432c-9e95-504bd0cfab5b}" FolderPath="Base\">
      <Declaration><![CDATA[METHOD PROTECTED _m_Hmi : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT SUPER^._m_Hmi() THEN
	RETURN;
END_IF

//Buttons
s_fbHmiBtnGoToIdle();
s_fbHmiBtnPickTrolleyFromTB();
s_fbHmiBtnPlaceTrolleyInTB();

//Leds

s_fbHmiLedTrolleyOnPositionLeft(i_bStaLed := s_bStaTrolleyOnPositionLeft);
s_fbHmiLedTrolleyOnPositionRight(i_bStaLed := s_bStaTrolleyOnPositionRight);
s_fbHmiLedCabinAreaOccupied(i_bStaLed := s_bStaCabinAreaOccupied);
s_fbHmiLedCollisionAvoidanceSensor(i_bStaLed := s_bStaCollisionAvoidanceSensor);
s_fbHmiLedTrolleyLocked(i_bStaLed := s_bStaTrolleyLocked);
s_fbHmiLedTrolleyUnlocked(i_bStaLed := NOT(s_bStaTrolleyLocked));

s_fbHmiLedAtIdlePosition(i_bStaLed := s_bStaAtIdlePosition);
s_fbHmiLedTrolleyPickedFromTB(i_bStaLed := s_bStaTrolleyPickedFromTB);
s_fbHmiLedTrolleyPlacedInTB(i_bStaLed := s_bStaTrolleyPlacedInTB);

_m_Hmi := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Init" Id="{fdcbf52e-0860-4b94-915e-8e7c2bbd0a27}" FolderPath="Base\">
      <Declaration><![CDATA[METHOD PROTECTED _m_Init : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT SUPER^._m_Init() THEN
	RETURN;
END_IF

//Control Modules
s_cmLift.i_bReqEnable := FALSE;
s_cmLift.i_eCtrlMode := E_CtrlMode.IDLE;
s_cmLift.i_sCmName := 'CM Lift';
s_cmLift.i_refAxis REF= axisLift;
{warning '#TODO: Replace homing, during test om real machine'}
s_cmLift.i_mcHomingMode := Tc2_MC2.MC_HomingMode.MC_Direct; //++Tc2_MC2.MC_HomingMode.MC_DefaultHoming;
s_cmLift.p_sCfgPosName := 'Up';
s_cmLift.p_sCfgNegName := 'Down';

s_cmTransport.i_bReqEnable := FALSE;
s_cmTransport.i_eCtrlMode := E_CtrlMode.IDLE;
s_cmTransport.i_sCmName := 'CM Transport Unit';
s_cmTransport.i_refAxis REF= axisTransport;
{warning '#TODO: Replace homing, during test om real machine'}
s_cmTransport.i_mcHomingMode := Tc2_MC2.MC_HomingMode.MC_Direct; //++Tc2_MC2.MC_HomingMode.MC_DefaultHoming;
s_cmTransport.p_sCfgPosName := 'Extract';
s_cmTransport.p_sCfgNegName := 'Retract';

s_diStaTrolleyOnPositionLeft.i_stSettings.tmInputDelay := T#100MS;
s_diStaTrolleyOnPositionRight.i_stSettings.tmInputDelay := T#100MS;
s_diStaCabinAreaOccupied.i_stSettings.tmInputDelay := T#100MS;
s_diStaCollisionAvoidanceSensor.i_stSettings.tmInputDelay := T#100MS;
s_diStaTrolleyLocked.i_stSettings.tmInputDelay := T#100MS;

//Interlock strings
//Lift
//[0].sReason --> External, dynamical will be written in m_input
s_fbIlckHandlerLiftDown.i_stInterlockList.arr_Interlocks[1].sReason := 'Transport not at retracted position';

//[0].sReason --> External, dynamical will be written in m_input
s_fbIlckHandlerLiftUp.i_stInterlockList.arr_Interlocks[1].sReason := 'Trolley not at correct position';

//Transport
//[0].sReason --> External, dynamical will be written in m_input
s_fbIlckHandlerTransportRetract.i_stInterlockList.arr_Interlocks[1].sReason := 'None';

//[0].sReason --> External, dynamical will be written in m_input
s_fbIlckHandlerTransportExtract.i_stInterlockList.arr_Interlocks[1].sReason := 'Lift not at correct position';
s_fbIlckHandlerTransportExtract.i_stInterlockList.arr_Interlocks[2].sReason := 'Collision Avoidance Active';

//Alarm config
s_fbAlarmHandlerLiftDrive.i_eAlarmLevel := E_AlarmLevel.Alarm;
s_fbAlarmHandlerTransportDrive.i_eAlarmLevel := E_AlarmLevel.Alarm;
s_fbAlarmHandlerLockTrolleyFailed.i_eAlarmLevel := E_AlarmLevel.Alarm;
s_fbAlarmHandlerUnlockTRolleyFailed.i_eAlarmLevel := E_AlarmLevel.Alarm;
s_fbAlarmHandlerNoTrolleyPlaced.i_eAlarmLevel := E_AlarmLevel.Alarm;
s_fbAlarmHandlerCabinNotEmpty.i_eAlarmLevel := E_AlarmLevel.Alarm;
s_fbAlarmHandlerCmdNotAllowed.i_eAlarmLevel := E_AlarmLevel.Alarm;

//Hmi
s_fbHmiBtnGoToIdle.p_eButtontype := E_HmiButtonType.PUSHBUTTON;
s_fbHmiBtnGoToIdle.p_bStaVisible := FALSE;
s_fbHmiBtnGoToIdle.p_bStaEnabled := FALSE;
s_fbHmiBtnGoToIdle.p_sBtnText := 'Go To Idle';

s_fbHmiBtnPickTrolleyFromTB.p_eButtontype := E_HmiButtonType.PUSHBUTTON;
s_fbHmiBtnPickTrolleyFromTB.p_bStaVisible := FALSE;
s_fbHmiBtnPickTrolleyFromTB.p_bStaEnabled := FALSE;
s_fbHmiBtnPickTrolleyFromTB.p_sBtnText := 'Pick Trolley From TB';

s_fbHmiBtnPlaceTrolleyInTB.p_eButtontype := E_HmiButtonType.PUSHBUTTON;
s_fbHmiBtnPlaceTrolleyInTB.p_bStaVisible := FALSE;
s_fbHmiBtnPlaceTrolleyInTB.p_bStaEnabled := FALSE;
s_fbHmiBtnPlaceTrolleyInTB.p_sBtnText := 'Place Trolley In TB';

s_fbHmiLedTrolleyOnPositionLeft.p_bStaVisible := FALSE;
s_fbHmiLedTrolleyOnPositionLeft.p_sToHmiDescriptionLed := 'Trolley On Position Left';

s_fbHmiLedTrolleyOnPositionRight.p_bStaVisible := FALSE;
s_fbHmiLedTrolleyOnPositionRight.p_sToHmiDescriptionLed := 'Trolley On Position Right';

s_fbHmiLedCabinAreaOccupied.p_bStaVisible := FALSE;
s_fbHmiLedCabinAreaOccupied.p_sToHmiDescriptionLed := 'Cabin Area Occupied';

s_fbHmiLedCollisionAvoidanceSensor.p_bStaVisible := FALSE;
s_fbHmiLedCollisionAvoidanceSensor.p_sToHmiDescriptionLed := 'Collision Avoidance Sensor';

s_fbHmiLedTrolleyLocked.p_bStaVisible := FALSE;
s_fbHmiLedTrolleyLocked.p_sToHmiDescriptionLed := 'Trolley Locked';

s_fbHmiLedTrolleyUnlocked.p_bStaVisible := FALSE;
s_fbHmiLedTrolleyUnlocked.p_sToHmiDescriptionLed := 'Trolley Unlocked';

s_fbHmiLedAtIdlePosition.p_bStaVisible := FALSE;
s_fbHmiLedAtIdlePosition.p_sToHmiDescriptionLed := 'At Idle Position';

s_fbHmiLedTrolleyPickedFromTB.p_bStaVisible := FALSE;
s_fbHmiLedTrolleyPickedFromTB.p_sToHmiDescriptionLed := 'Trolley Picked From TB';

s_fbHmiLedTrolleyPlacedInTB.p_bStaVisible := FALSE;
s_fbHmiLedTrolleyPlacedInTB.p_sToHmiDescriptionLed := 'Trolley Placed In TB';

_m_Init := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Inputs" Id="{2c09f905-698a-4dfd-8c60-1a7d7f6d646b}" FolderPath="Base\">
      <Declaration><![CDATA[METHOD PROTECTED _m_Inputs : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT SUPER^._m_Inputs() THEN
	RETURN;
END_IF

//Convert Lift and Transport Unit positons to actula translations
s_cmLift.p_fSetTargetPosition := _m_ConvLiftHeightToSpindPos(s_fSetLiftPosition);
s_cmTransport.p_fSetTargetPosition := s_fSetTransportPosition * 0.5;

//Interlocks
_m_Interlocks();

_m_Inputs := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Interlocks" Id="{d0273455-0a55-4429-837d-4f1e324db3f4}" FolderPath="Base\">
      <Declaration><![CDATA[METHOD PROTECTED _m_Interlocks
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//Lift/////////////////////////////////////////////////////////////////////////////////////////////
s_fbIlckHandlerLiftDown.i_stInterlockList.arr_Interlocks[0] := i_stExtIlckLiftDown;
s_fbIlckHandlerLiftDown.i_stInterlockList.arr_Interlocks[1].bState := //Transport not at retracter positon + starts at min level
	( (s_fActTransportPosition < c_fMIN_TRANSPORT_POSITION_TO_LOWER_LIFT) OR (s_fActTransportPosition > c_fMAX_TRANSPORT_POSITION_TO_LOWER_LIFT) )
	AND (s_fActLiftPosition < c_fMIN_LIFT_POSITION_TO_CHECK_INTERLOCK );
s_fbIlckHandlerLiftDown();

s_fbIlckHandlerLiftUp.i_stInterlockList.arr_Interlocks[0] := i_stExtIlckLiftUp;
s_fbIlckHandlerLiftUp.i_stInterlockList.arr_Interlocks[1].bState := //Trolley not placed correctly at lift
	NOT(s_bStaCabinAreaFree)
	AND NOT (s_bStaTrolleyAtLiftPos)
	AND (s_fActLiftPosition < c_fMAX_LIFT_POSITION_TO_CHECK_TROLLEY );
s_fbIlckHandlerLiftUp();

s_bIlckLiftDown := s_fbIlckHandlerLiftDown.p_bInterlocked;
s_bIlckLiftUp := s_fbIlckHandlerLiftUp.p_bInterlocked;

IF s_bIlckLiftDown THEN
	s_cmLift.p_sInterlockedReasonNeg := s_fbIlckHandlerLiftDown.p_sReason;
ELSE
	s_cmLift.p_sInterlockedReasonNeg := '-';
END_IF
	
IF s_bIlckLiftUp THEN
	s_cmLift.p_sInterlockedReasonPos := s_fbIlckHandlerLiftUp.p_sReason;
ELSE
	s_cmLift.p_sInterlockedReasonPos := '-';
END_IF

//Transport////////////////////////////////////////////////////////////////////////////////////////
s_fbIlckHandlerTransportRetract.i_stInterlockList.arr_Interlocks[0] := i_stExtIlckTransportRetract;
s_fbIlckHandlerTransportRetract.i_stInterlockList.arr_Interlocks[1].bState := FALSE;
s_fbIlckHandlerTransportRetract();

s_fbIlckHandlerTransportExtract.i_stInterlockList.arr_Interlocks[0] := i_stExtIlckTransportExtract;
s_fbIlckHandlerTransportExtract.i_stInterlockList.arr_Interlocks[1].bState := //Lift not at correct position
	(i_eCtrlMode <> E_CtrlMode.AUTOMATIC) AND (i_eCtrlMode <> E_CtrlMode.MANUAL) AND
	((s_fActLiftPosition < c_fMIN_LIFT_HEIGHT_TO_EXTRACT_TRANSPORT) OR (s_fActLiftPosition > c_fMAX_LIFT_HEIGHT_TO_EXTRACT_TRANSPORT) );
s_fbIlckHandlerTransportExtract.i_stInterlockList.arr_Interlocks[2].bState := s_bStaCollisionAvoidanceSensor AND (s_fActTransportPosition < c_fEND_TRANSPORT_POSITION_COLLISION_CHECK) AND FALSE;
s_fbIlckHandlerTransportExtract();

s_bIlckTransportRetract := s_fbIlckHandlerTransportRetract.p_bInterlocked;
s_bIlckTransportExtract := s_fbIlckHandlerTransportExtract.p_bInterlocked;

IF s_bIlckTransportRetract THEN
	s_cmTransport.p_sInterlockedReasonNeg := s_fbIlckHandlerTransportRetract.p_sReason;
ELSE
	s_cmTransport.p_sInterlockedReasonNeg := '-';
END_IF
	
IF s_bIlckTransportExtract THEN
	s_cmTransport.p_sInterlockedReasonPos := s_fbIlckHandlerTransportExtract.p_sReason;
ELSE
	s_cmTransport.p_sInterlockedReasonPos := '-';
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Outputs" Id="{0027b51b-0e3b-4c47-b79c-c262d8cada1b}" FolderPath="Base\">
      <Declaration><![CDATA[METHOD PROTECTED _m_Outputs : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT SUPER^._m_Outputs() THEN
	RETURN;
END_IF

//Calculate actual positions of Lift and Transport
s_fActLiftPosition := _m_ConvSpindPosToLiftHeight(s_cmLift.p_fPosition);
s_fActTransportPosition := s_cmTransport.p_fPosition * 2.0;

//Get STO-input-state from transport servo drive
Q_bDriveStateSTO := I_nInfoDataInputLevel.8; //bit8 is the state of the STO input of the servo drive terminal

q_bStaWarning := s_bStaWarning;

_m_Outputs := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Params" Id="{5f8e46d4-1bd2-48a0-a796-5af6a0b2577f}" FolderPath="Base\">
      <Declaration><![CDATA[METHOD PROTECTED _m_Params : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT SUPER^._m_Params() THEN
	RETURN;
END_IF

//Write to settings
{warning '#TODO: Check what nees to be added here, is it nessecary add a fbParam for each parameter?'}
	
//++i_ref_stSettings.fSpeedManual := s_fbParamSpeedManual.p_fValue;

//++i_ref_stSettings.stLiftSpeedProfileJogging :=
//++i_ref_stSettings.stLiftSpeedProfilePositioning := 
//++i_ref_stSettings.

_m_Params := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_m_Sequence" Id="{adfb5128-2b00-4a29-b7de-b50ba035879a}">
      <Declaration><![CDATA[METHOD PROTECTED _m_Sequence : BOOL
VAR
	s_bError : BOOL;
	s_bDontWait : BOOL; //local written from setting
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//Register previous step
IF s_eSequence <> s_ePreviousStep
	AND s_eSequence <> E_SeqLiftingTransport.STOP
	AND s_eSequence <> E_SeqLiftingTransport.ERROR THEN
	s_ePreviousStep := s_eSequence;
END_IF

s_bDontWait := NOT(i_ref_stSettings.bWaitForNextStep);

s_fbSeqControl(
	i_nSeqStep := s_eSequence,
	i_sStepName := TO_STRING(s_eSequence),
	i_bCmdReset :=
		i_bCmdReset
		AND i_bReqEnable
		AND (s_eSequence = E_SeqLiftingTransport.ERROR) // Only reset/resume sequencer from ERROR state
		AND NOT(s_bStaError),
	i_bStaError := s_bStaError OR NOT(i_bReqEnable));
	
	s_bActionDone R= s_fbSeqControl.q_bStaEntry;
	
//Force to stop
IF (i_eCtrlState = E_CtrlState.STOPPING) THEN
	s_eSequence := E_SeqLiftingTransport.STOP;
END_IF

//Load last step from persistent memory
IF (s_eSequence > E_SeqLiftingTransport.START) AND (s_eSequence < E_SeqLiftingTransport.STOP) THEN
	s_eLastStepPersistent := s_eSequence;
END_IF

s_sResumeStep := TO_STRING(s_eResumeStep);

CASE s_eSequence OF
	E_SeqLiftingTransport.IDLE:
		s_eResumeStep := E_SeqLiftingTransport.READY;
		s_eSequence := E_SeqLiftingTransport.START;
		
	E_SeqLiftingTransport.START:  // Afhankelijk van de voorgaande stap, stappen programma hervatten. Wanneer actie voltooit
		IF s_fbSeqControl.q_bStaEntry THEN
			s_sMessage := 'start';
		END_IF
		
		IF i_eCtrlState = E_CtrlState.RUNNING THEN
			s_eSequence := s_eResumeStep;
		END_IF
		
///////////////////////////////////////////////////////////////////////////////////////////////////
// READY //////////////////////////////////////////////////////////////////////////////////////////
	E_SeqLiftingTransport.READY:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_eResumeStep := E_SeqLiftingTransport.READY;
		END_IF
		
		IF s_bReqGoToIdle THEN
			IF _m_CmdGoToIdle(i_refReason := s_sMessage) THEN
				s_eSequence := E_SeqLiftingTransport.TRANSPORT_TO_IDLE;
			//ELSE	If failed (command not allowed): the message will be written with the interlock reason
			END_IF
			s_bReqGoToIdle := FALSE;
			
		ELSIF s_bReqPickTrolleyFromTB THEN
			IF _m_CmdPickTrolleyFromTB(i_refReason := s_sMessage) THEN
				s_eSequence := E_SeqLiftingTransport.LIFT_PRE_PICK_FROM_TB;
			//ELSE	If failed (command not allowed): the message will be written with the interlock reason
			END_IF
			s_bReqPickTrolleyFromTB := FALSE;
			
		ELSIF s_bReqPlaceTrolleyInTB THEN
			IF _m_CmdPlaceTrolleyInTB(i_refReason := s_sMessage) THEN
				s_eSequence := E_SeqLiftingTransport.LIFT_PRE_PICK_FROM_CABIN;
			//ELSE	If failed (command not allowed): the message will be written with the interlock reason
			END_IF
			s_bReqPlaceTrolleyInTB := FALSE;
		END_IF
		
///////////////////////////////////////////////////////////////////////////////////////////////////
// GO TO IDLE /////////////////////////////////////////////////////////////////////////////////////
	E_SeqLiftingTransport.TRANSPORT_TO_IDLE:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmTransport.m_MoveAbsolute(_m_ConvTranspToMotorPos(i_ref_stSettings.arr_stTransportPositioningProfile[0]));
		END_IF
		
		s_bActionDone S= s_cmTransport.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.LIFT_TO_IDLE;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.LIFT_TO_IDLE:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmLift.m_MoveAbsolute(_m_ConvLiftToMotorPos(i_ref_stSettings.arr_stLiftPositioningProfile[0]));
		END_IF
		
		s_bActionDone S= s_cmLift.p_bMoveAbsDone;
		
		IF s_bActionDone THEN
			//s_bStaAtIdlePosition := TRUE;	will be set based on the actual position(s)						    /////////////////////
			s_eSequence := E_SeqLiftingTransport.READY;
		
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
///////////////////////////////////////////////////////////////////////////////////////////////////
/// PICK TROLLEY FROM TB //////////////////////////////////////////////////////////////////////////
	E_SeqLiftingTransport.LIFT_PRE_PICK_FROM_TB:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmLift.m_MoveAbsolute(_m_ConvLiftToMotorPos(i_ref_stSettings.arr_stLiftPositioningProfile[1]));
			s_bStaTrolleyPlacedInTB := FALSE;
		END_IF
		
		s_bActionDone S= s_cmLift.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.TRANSPORT_PRE_PICK_FROM_TB;
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.TRANSPORT_PRE_PICK_FROM_TB:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmTransport.m_MoveAbsolute(_m_ConvTranspToMotorPos(i_ref_stSettings.arr_stTransportPositioningProfile[1]));
		END_IF
		
		s_bActionDone S= s_cmTransport.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.TRANSPORT_PICK_FROM_TB;
		
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.TRANSPORT_PICK_FROM_TB:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmTransport.m_MoveAbsolute(_m_ConvTranspToMotorPos(i_ref_stSettings.arr_stTransportPositioningProfile[2]));
		END_IF
		
		s_bActionDone S= s_cmTransport.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.LIFT_PICK_FROM_TB;
		
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.LIFT_PICK_FROM_TB:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmLift.m_MoveAbsolute(_m_ConvLiftToMotorPos(i_ref_stSettings.arr_stLiftPositioningProfile[2]));
		END_IF
		
		s_bActionDone S= s_cmLift.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.CHECK_TROLLEY_UNLOCKED;
		
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.CHECK_TROLLEY_UNLOCKED:
		IF (s_fbSeqControl.q_tmStepTime > T#3S)
			AND NOT(s_bStaTrolleyLocked) AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.LIFT_RAISE_FROM_TB;
			
		ELSIF s_fbSeqControl.q_tmStepTime > T#10S THEN
			IF i_ref_stSettings.bAutoRecoveryToIdle THEN
				s_eSequence := E_SeqLiftingTransport.RECOVERY_UNLOCKED_FAILED;
			ELSE
				s_bErrUnlockTrolleyFailed := TRUE;
				s_eSequence := E_SeqLiftingTransport.ERROR;
			END_IF
		END_IF
		
	E_SeqLiftingTransport.RECOVERY_UNLOCKED_FAILED:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmLift.m_MoveAbsolute(_m_ConvLiftToMotorPos(i_ref_stSettings.arr_stLiftPositioningProfile[1]));
		END_IF
		
		s_bActionDone S= s_cmLift.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.TRANSPORT_TO_IDLE;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.LIFT_RAISE_FROM_TB:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmLift.m_MoveAbsolute(_m_ConvLiftToMotorPos(i_ref_stSettings.arr_stLiftPositioningProfile[3]));
		END_IF
		
		s_bActionDone S= s_cmLift.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.TRANSPORT_PLACE_IN_CABIN;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.TRANSPORT_PLACE_IN_CABIN:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmTransport.m_MoveAbsolute(_m_ConvTranspToMotorPos(i_ref_stSettings.arr_stTransportPositioningProfile[3]));
		END_IF
		
		s_bActionDone S= s_cmTransport.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.LIFT_PRE_PLACE_IN_CABIN;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.LIFT_PRE_PLACE_IN_CABIN:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmLift.m_MoveAbsolute(_m_ConvLiftToMotorPos(i_ref_stSettings.arr_stLiftPositioningProfile[4]));
		END_IF
		
		s_bActionDone S= s_cmLift.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.LIFT_PLACE_IN_CABIN;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.LIFT_PLACE_IN_CABIN:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmLift.m_MoveAbsolute(_m_ConvLiftToMotorPos(i_ref_stSettings.arr_stLiftPositioningProfile[5]));
		END_IF
		
		s_bActionDone S= s_cmLift.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.CHECK_TROLLEY_PLACED;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.CHECK_TROLLEY_PLACED:
		IF s_bStaTrolleyAtLiftPos THEN
			s_bStaTrolleyPickedFromTB := TRUE;												/////////////////////
			s_eSequence := E_SeqLiftingTransport.READY;
		ELSIF (s_fbSeqControl.q_tmStepTime > T#3S) THEN
			s_bStaTrolleyPickedFromTB := FALSE;
			s_bErrNoTrolleyPlaced := TRUE;
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
///////////////////////////////////////////////////////////////////////////////////////////////////
/// PICK TROLLEY FROM CABIN ///////////////////////////////////////////////////////////////////////
	E_SeqLiftingTransport.LIFT_PRE_PICK_FROM_CABIN:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmLift.m_MoveAbsolute(_m_ConvLiftToMotorPos(i_ref_stSettings.arr_stLiftPositioningProfile[6]));
			s_bStaTrolleyPickedFromTB := FALSE;
		END_IF
		
		s_bActionDone S= s_cmLift.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.LIFT_PICK_FROM_CABIN;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.LIFT_PICK_FROM_CABIN:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmLift.m_MoveAbsolute(_m_ConvLiftToMotorPos(i_ref_stSettings.arr_stLiftPositioningProfile[7]));
		END_IF
		
		s_bActionDone S= s_cmLift.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.LIFT_RAISE_FROM_CABIN;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.LIFT_RAISE_FROM_CABIN:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmLift.m_MoveAbsolute(_m_ConvLiftToMotorPos(i_ref_stSettings.arr_stLiftPositioningProfile[8]));
		END_IF
		
		s_bActionDone S= s_cmLift.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.TRANSPORT_PRE_PLACE_IN_TB;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.TRANSPORT_PRE_PLACE_IN_TB:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmTransport.m_MoveAbsolute(_m_ConvTranspToMotorPos(i_ref_stSettings.arr_stTransportPositioningProfile[4]));
		END_IF
		
		s_bActionDone S= s_cmTransport.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.TRANSPORT_PLACE_IN_TB;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.TRANSPORT_PLACE_IN_TB:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmTransport.m_MoveAbsolute(_m_ConvTranspToMotorPos(i_ref_stSettings.arr_stTransportPositioningProfile[5]));
		END_IF
		
		s_bActionDone S= s_cmTransport.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.LIFT_PRE_PLACE_IN_TB;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.LIFT_PRE_PLACE_IN_TB:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmLift.m_MoveAbsolute(_m_ConvLiftToMotorPos(i_ref_stSettings.arr_stLiftPositioningProfile[9]));
		END_IF
		
		s_bActionDone S= s_cmLift.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.LIFT_PLACE_IN_TB;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.LIFT_PLACE_IN_TB:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmLift.m_MoveAbsolute(_m_ConvLiftToMotorPos(i_ref_stSettings.arr_stLiftPositioningProfile[10]));
		END_IF
		
		s_bActionDone S= s_cmLift.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.CHECK_TROLLEY_LOCKED;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.CHECK_TROLLEY_LOCKED:
		IF (s_fbSeqControl.q_tmStepTime > T#3S)
			AND s_bStaTrolleyLocked AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_bStaTrolleyPlacedInTB := TRUE; //Note can be resetted
			s_eSequence := E_SeqLiftingTransport.TRANSPORT_RETURN_IN_CABIN;
			
		ELSIF s_fbSeqControl.q_tmStepTime > T#10S THEN
			IF i_ref_stSettings.bAutoRecoveryToIdle THEN
			s_eSequence := E_SeqLiftingTransport.RECOVERY_LOCKED_FAILED;
			ELSE
				s_bErrLockTrolleyFailed := TRUE;
				s_eSequence := E_SeqLiftingTransport.ERROR;
			END_IF
		END_IF
		
	E_SeqLiftingTransport.RECOVERY_LOCKED_FAILED:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmLift.m_MoveAbsolute(_m_ConvLiftToMotorPos(i_ref_stSettings.arr_stLiftPositioningProfile[8]));
		END_IF
		
		s_bActionDone S= s_cmLift.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.TRANSPORT_TO_IDLE;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.TRANSPORT_RETURN_IN_CABIN:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmTransport.m_MoveAbsolute(_m_ConvTranspToMotorPos(i_ref_stSettings.arr_stTransportPositioningProfile[0]));
		END_IF
		
		s_bActionDone S= s_cmTransport.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.LIFT_RETURN_IN_CABIN;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.LIFT_RETURN_IN_CABIN:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmLift.m_MoveAbsolute(_m_ConvLiftToMotorPos(i_ref_stSettings.arr_stLiftPositioningProfile[0]));
		END_IF
			
		s_bActionDone S= s_cmLift.p_bMoveAbsDone;
		
		IF s_bActionDone AND (s_bNextStep OR s_bDontWait) THEN
			s_bNextStep := FALSE;
			s_eSequence := E_SeqLiftingTransport.CHECK_CABIN_EMPTY;
			
		ELSIF s_bError THEN
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
	E_SeqLiftingTransport.CHECK_CABIN_EMPTY:
		IF s_bStaCabinAreaFree THEN
			s_bStaTrolleyPlacedInTB := TRUE;												/////////////////////
			s_eSequence := E_SeqLiftingTransport.READY;
		ELSIF (s_fbSeqControl.q_tmStepTime > T#3S) THEN
			s_bStaTrolleyPlacedInTB := FALSE;
			s_bErrCabinNotEmpty := TRUE;
			s_eSequence := E_SeqLiftingTransport.ERROR;
		END_IF
		
///////////////////////////////////////////////////////////////////////////////////////////////////
// STOP ///////////////////////////////////////////////////////////////////////////////////////////
	E_SeqLiftingTransport.STOP:
		IF s_fbSeqControl.q_bStaEntry THEN
			s_cmLift.m_Stop(
				i_fDec := i_ref_stSettings.stSettingsServoLift.fStopDec,
				i_fJrk := i_ref_stSettings.stSettingsServoLift.fStopJrk);
				
			s_cmTransport.m_Stop(
				i_fDec := i_ref_stSettings.stSettingsServoTransport.fStopDec,
				i_fJrk := i_ref_stSettings.stSettingsServoTransport.fStopJrk);
				
			IF s_ePreviousStep > E_SeqLiftingTransport.START
				AND s_ePreviousStep < E_SeqLiftingTransport.ERROR THEN
					s_eResumeStep := s_ePreviousStep;
			END_IF
		END_IF
		
		IF i_eCtrlState = E_CtrlState.IDLE THEN
			s_eSequence := E_SeqLiftingTransport.START;
		END_IF
		
///////////////////////////////////////////////////////////////////////////////////////////////////
// ERROR //////////////////////////////////////////////////////////////////////////////////////////
	E_SeqLiftingTransport.ERROR:
		IF s_fbSeqControl.q_bStaEntry THEN
			IF s_ePreviousStep > E_SeqLiftingTransport.START
				AND s_ePreviousStep < E_SeqLiftingTransport.ERROR THEN
					s_eResumeStep := s_ePreviousStep;
			END_IF
		END_IF
		
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_Main" Id="{7d708d4c-1fee-4511-a8d0-db3dbe3fd7e6}" FolderPath="Base\">
      <Declaration><![CDATA[METHOD PUBLIC m_Main : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT SUPER^.m_Main() THEN
	RETURN;
END_IF

CASE i_eCtrlMode OF
	E_CtrlMode.IDLE:
		s_eSequence := E_SeqLiftingTransport.IDLE;
		
	E_CtrlMode.AUTOMATIC:
		//Automatic commands are controlled by higher-layer unit
		_m_AutomaticControl();
		
	E_CtrlMode.MANUAL:
		//Execute manaual control (based on HMI buttons)
		
		//Manual commands (convert HMI buttons to requests), only in state running
		IF (i_eCtrlState = E_CtrlState.RUNNING) THEN
			s_bReqGoToIdle := s_fbHmiBtnGoToIdle.p_osrBtnPress;
			s_bReqPickTrolleyFromTB := s_fbHmiBtnPickTrolleyFromTB.p_osrBtnPress;
			s_bReqPlaceTrolleyInTB := s_fbHmiBtnPlaceTrolleyInTB.p_osrBtnPress;
		END_IF
		
		_m_AutomaticControl();
		
	E_CtrlMode.MAINTENANCE:
		//Execute maintenance control (HMI control module buttons)
		//Reset automatic/manual sequencer
		s_eSequence := E_SeqLiftingTransport.IDLE;
		
		; 	//Maintenance control is implemented in lower-layer control modules
		
	E_CtrlMode.IO:
		//Execute IO-test control (HMI output force control)
		; 	//IO-Test control is implemented in lower-layer control modules
			//Enabling control is done direcly under this case instruction
		
	E_CtrlMode.CLEANING:
		//Execute cleaning control (cleaning  specific functionalities)
		;	//Cleaning control is not implemented, this could be a done in the future if neccesary
		
END_CASE

//AUTOMATIC-mode //////////////////////////////////////////////////////////////////////////////////

//MANUAL-mode /////////////////////////////////////////////////////////////////////////////////////

//Buttons visibility
IF (i_eCtrlMode = E_CtrlMode.MANUAL) THEN
	s_fbHmiBtnGoToIdle.p_bStaVisible := TRUE;
	s_fbHmiBtnPickTrolleyFromTB.p_bStaVisible := TRUE;
	s_fbHmiBtnPlaceTrolleyInTB.p_bStaVisible := TRUE;
ELSE
	s_fbHmiBtnGoToIdle.p_bStaVisible := FALSE;
	s_fbHmiBtnPickTrolleyFromTB.p_bStaVisible := FALSE;
	s_fbHmiBtnPlaceTrolleyInTB.p_bStaVisible := FALSE;
END_IF

//Buttons enabling
IF i_bReqEnable AND (i_eCtrlMode = E_CtrlMode.MANUAL) AND (i_eCtrlState = E_CtrlState.RUNNING) THEN
	
	//Lift/Transport
	s_fbHmiBtnGoToIdle.p_bStaEnabled :=
		//**NOT(s_bIlckLiftDown)
		//--AND NOT(s_bIlckLiftUp)
		//**AND NOT(s_bIlckTransportRetract)
		//--AND NOT(s_bIlckTransportExtract)
		NOT(s_cmLift.p_bStaError)
		AND NOT(s_cmTransport.p_bStaError);
		
	s_fbHmiBtnPickTrolleyFromTB.p_bStaEnabled :=
		//--NOT(s_bIlckLiftDown)
		NOT(s_bIlckLiftUp)
		//--AND NOT(s_bIlckTransportRetract)
		AND NOT(s_bIlckTransportExtract)
		AND NOT(s_cmLift.p_bStaError)
		AND NOT(s_cmTransport.p_bStaError);
		
	s_fbHmiBtnPlaceTrolleyInTB.p_bStaEnabled :=
		//--NOT(s_bIlckLiftDown)
		NOT(s_bIlckLiftUp)
		//--AND NOT(s_bIlckTransportRetract)
		//--AND NOT(s_bIlckTransportExtract)
		AND NOT(s_cmLift.p_bStaError)
		AND NOT(s_cmTransport.p_bStaError);
		
ELSE
	s_fbHmiBtnGoToIdle.p_bStaEnabled := FALSE;
	s_fbHmiBtnPickTrolleyFromTB.p_bStaEnabled := FALSE;
	s_fbHmiBtnPlaceTrolleyInTB.p_bStaEnabled := FALSE;
END_IF

//MAINTENANCE-mode ////////////////////////////////////////////////////////////////////////////////

//Stopping control modules
IF (i_eCtrlMode = E_CtrlMode.MAINTENANCE) AND (i_eCtrlState = E_CtrlState.STOPPING) THEN
	//Stop both axes
	s_cmLift.m_Stop(
		i_fDec := i_ref_stSettings.stSettingsServoLift.fStopDec,
		i_fJrk := i_ref_stSettings.stSettingsServoLift.fStopJrk);
		
	s_cmTransport.m_Stop(
		i_fDec := i_ref_stSettings.stSettingsServoTransport.fStopDec,
		i_fJrk := i_ref_stSettings.stSettingsServoTransport.fStopJrk);
END_IF

//IO-mode /////////////////////////////////////////////////////////////////////////////////////////
IF (i_eCtrlMode = E_CtrlMode.IO) AND (i_eCtrlState = E_CtrlState.RUNNING) THEN
	s_bHmiForceOutputEnabled := TRUE;
ELSE
	s_bHmiForceOutputEnabled := FALSE;
END_IF

m_Main := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_ReqGoToIdle" Id="{9d30bbef-bcd6-4fc2-8d93-9b2201ca737f}">
      <Declaration><![CDATA[METHOD PUBLIC m_ReqGoToIdle : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT i_bReqEnable THEN
	RETURN;
END_IF

s_bReqGoToIdle := TRUE;

m_ReqGoToIdle := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_ReqPickTrolleyFromTB" Id="{bc26af41-4ec1-4049-ae2f-a8f4c7a26c9b}">
      <Declaration><![CDATA[METHOD PUBLIC m_ReqPickTrolleyFromTB : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT i_bReqEnable THEN
	RETURN;
END_IF

s_bReqPickTrolleyFromTB := TRUE;

m_ReqPickTrolleyFromTB := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_ReqPlaceTrolleyInTB" Id="{fa516528-012b-4031-8e18-317ece30b039}">
      <Declaration><![CDATA[METHOD PUBLIC m_ReqPlaceTrolleyInTB : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT i_bReqEnable THEN
	RETURN;
END_IF

s_bReqPlaceTrolleyInTB := TRUE;

m_ReqPlaceTrolleyInTB := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Property Name="p_bStaAtIdlePosition" Id="{050383f4-1821-4a98-ab50-f2e654340431}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY PUBLIC p_bStaAtIdlePosition : BOOL]]></Declaration>
      <Get Name="Get" Id="{03f3f379-9c7e-473c-8407-742758c9f4b6}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[
p_bStaAtIdlePosition := s_bStaAtIdlePosition;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="p_bStaReady" Id="{9809bc6e-a3c0-4ee9-a4ff-5ea4620f2056}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY PUBLIC p_bStaReady : BOOL]]></Declaration>
      <Get Name="Get" Id="{5e8a02fa-d605-4ec3-b56c-668982e96dc2}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[
p_bStaReady := (s_eSequence = E_SeqLiftingTransport.READY);
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="p_bStaTrollPickedFromTB" Id="{630d4760-3c9e-490a-b1db-ceb84ce3b93d}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY PUBLIC p_bStaTrollPickedFromTB : BOOL]]></Declaration>
      <Get Name="Get" Id="{ac0f1cfe-6ddb-4648-8ead-590b388c0171}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[
p_bStaTrollPickedFromTB := s_bStaTrolleyPickedFromTB;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="p_bStaTrollPlacedInTB" Id="{ccba55b7-671b-48a2-af2d-7bdd569222c9}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY PUBLIC p_bStaTrollPlacedInTB : BOOL]]></Declaration>
      <Get Name="Get" Id="{c55ed7dc-3eae-49e0-bba0-c67b4ed5fb10}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[
p_bStaTrollPlacedInTB := s_bStaTrolleyPlacedInTB;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="p_fActLiftPosition" Id="{4d4dec4b-65ac-47fc-b6dc-1f3f9ac40ec7}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY PUBLIC p_fActLiftPosition : LREAL]]></Declaration>
      <Get Name="Get" Id="{b30e29b1-c6ab-4fb2-931c-73cdaa138f9e}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[
p_fActLiftPosition := s_fActLiftPosition;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="p_fActTransportPosition" Id="{7d7cecdd-10b1-4526-adcf-7530f743bf70}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY PUBLIC p_fActTransportPosition : LREAL]]></Declaration>
      <Get Name="Get" Id="{6ea66e94-77ed-4824-8bdd-a13b06ccdacc}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[
p_fActTransportPosition := s_fActTransportPosition;
]]></ST>
        </Implementation>
      </Get>
    </Property>
  </POU>
</TcPlcObject>